import { buildTheme, createColorTheme as createColorTheme$1, hexToRgb as hexToRgb$1, hslToRgb as hslToRgb$1, multiply as multiply$1, parseColor as parseColor$1, rgbToHex as rgbToHex$1, rgbToHsl as rgbToHsl$1, rgba as rgba$1, screen as screen$1, getTheme_v2, getScopedTheme } from "@sanity/ui/theme";
import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { useMemo, useState, useRef, useEffect, useDebugValue, useImperativeHandle, useSyncExternalStore, createContext, useContext, forwardRef, useId, Children, isValidElement, cloneElement, useCallback, Component, memo, useLayoutEffect, useReducer, Fragment as Fragment$1, startTransition } from "react";
import ReactIs, { isValidElementType } from "react-is";
import { ThemeProvider as ThemeProvider$1, useTheme as useTheme$1, css, styled, keyframes } from "styled-components";
import { SpinnerIcon, CheckmarkIcon, RemoveIcon, ChevronDownIcon, CloseIcon, ChevronRightIcon, ToggleArrowRightIcon } from "@sanity/icons";
import Refractor from "react-refractor";
import { detectOverflow, flip, offset, shift, arrow, hide, useFloating, autoUpdate } from "@floating-ui/react-dom";
import { motion, AnimatePresence } from "framer-motion";
import { createPortal } from "react-dom";
import { useEffectEvent } from "use-effect-event";
import { getTheme_v2 as getTheme_v2$1 } from "./_chunks-es/getTheme_v2.mjs";
const createColorTheme = createColorTheme$1, hexToRgb = hexToRgb$1, hslToRgb = hslToRgb$1, multiply = multiply$1, parseColor = parseColor$1, rgbToHex = rgbToHex$1, rgbToHsl = rgbToHsl$1, rgba = rgba$1, screen = screen$1, studioTheme = buildTheme(), EMPTY_ARRAY = [], EMPTY_RECORD = {}, POPOVER_MOTION_CONTENT_OPACITY_PROPERTY = "--motion-content-opacity", POPOVER_MOTION_PROPS = {
  initial: {
    opacity: 0.5,
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
    scale: 0.97,
    willChange: "transform"
  },
  animate: {
    opacity: [null, 1, 1],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, null, 1],
    scale: 1
  },
  exit: {
    // @ts-expect-error -- passing null a second time is valid: https://github.com/framer/motion/blob/b9ce4c42914c3916ea523609c5b032dfc72718bb/packages/framer-motion/src/animation/utils/keyframes.ts#L34C22-L34C22
    opacity: [null, null, 0],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, 0, 0],
    scale: 0.97
  },
  transition: {
    duration: 0.4,
    type: "spring"
  }
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => (style[key2] = value, style), {});
}
function rem(pixelValue) {
  return pixelValue === 0 ? 0 : `${pixelValue / 16}rem`;
}
function _responsive(media, values, callback) {
  return (values?.map(callback) || []).map((statement, mediaIndex) => mediaIndex === 0 ? statement : {
    [`@media screen and (min-width: ${media[mediaIndex - 1]}px)`]: statement
  });
}
function _getArrayProp(val, defaultVal) {
  return val === void 0 ? defaultVal || EMPTY_ARRAY : Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props, spaceIndexes = EMPTY_ARRAY) {
  if (!Array.isArray(spaceIndexes))
    throw new Error("the property must be array of numbers");
  if (spaceIndexes.length === 0)
    return null;
  const {
    media,
    space
  } = getTheme_v2(theme);
  return _responsive(media, spaceIndexes, (spaceIndex) => _fillCSSObject(props, rem(space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme), {
    family,
    sizes,
    weights
  } = font[fontKey], fontWeight = $weight && weights[$weight] || weights.regular, defaultSize = sizes[2], base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size)
    return responsiveFont.warned || (console.warn("No size specified for responsive font", {
      fontKey,
      $size,
      props,
      base
    }), responsiveFont.warned = !0), [base];
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size2) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size2, negHeight = ascenderHeight + descenderHeight, capHeight = lineHeight - negHeight, iconOffset = (capHeight - iconSize) / 2, customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1, customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: `calc(${lineHeight} / ${fontSize2})`,
    letterSpacing: rem(letterSpacing),
    transform: `translateY(${rem(descenderHeight)})`,
    "&:before": {
      marginTop: `calc(${rem(0 - negHeight)} - 1px)`
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: `calc(${customIconSize} / 16 * 1rem)`,
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: `calc(${iconSize} / 16 * 1rem)`,
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (textAlign) => ({
    textAlign
  }));
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = useMemo(() => JSON.stringify(val ?? defaultVal), [defaultVal, val]);
  return useMemo(
    () => _getArrayProp(val, defaultVal),
    // Improve performance: Keep object identify for a given hash of the value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [__perf_hash__]
  );
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg)
    Array.isArray(el) ? ret.push(...el) : ret.push(el);
  return ret.filter(Boolean);
}
function useClickOutside(listener, t0, boundaryElement) {
  const $ = c(12), elementsArg = t0 === void 0 ? EMPTY_ARRAY : t0, [element, setElement] = useState(null);
  let t1;
  $[0] !== element || $[1] !== elementsArg ? (t1 = () => _getElements(element, elementsArg), $[0] = element, $[1] = elementsArg, $[2] = t1) : t1 = $[2];
  const [elements, setElements] = useState(t1), elementsRef = useRef(elements);
  let t2, t3;
  $[3] !== element || $[4] !== elementsArg ? (t2 = () => {
    const prevElements = elementsRef.current, nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements), elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements)
      if (!nextElements.includes(el)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
    for (const el_0 of nextElements)
      if (!prevElements.includes(el_0)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
  }, t3 = [element, elementsArg], $[3] = element, $[4] = elementsArg, $[5] = t2, $[6] = t3) : (t2 = $[5], t3 = $[6]), useEffect(t2, t3);
  let t4, t5;
  return $[7] !== listener || $[8] !== boundaryElement || $[9] !== elements ? (t4 = () => {
    if (!listener)
      return;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (target instanceof Node && !(boundaryElement && !boundaryElement.contains(target))) {
        for (const el_1 of elements)
          if (target === el_1 || el_1.contains(target))
            return;
        listener(evt);
      }
    };
    return window.addEventListener("mousedown", handleWindowMouseDown), () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, t5 = [boundaryElement, listener, elements], $[7] = listener, $[8] = boundaryElement, $[9] = elements, $[10] = t4, $[11] = t5) : (t4 = $[10], t5 = $[11]), useEffect(t4, t5), setElement;
}
function useClickOutsideEvent(listener, t0, boundaryElement) {
  const $ = c(8), elementsArg = t0 === void 0 ? _temp$6 : t0;
  let t1;
  $[0] !== listener || $[1] !== boundaryElement || $[2] !== elementsArg ? (t1 = (evt) => {
    if (!listener)
      return;
    const target = evt.target;
    if (!(target instanceof Node))
      return;
    const resolvedBoundaryElement = boundaryElement?.();
    if (resolvedBoundaryElement && !resolvedBoundaryElement.contains(target))
      return;
    const elements = elementsArg().flat();
    for (const el of elements)
      if (el && (target === el || el.contains(target)))
        return;
    listener(evt);
  }, $[0] = listener, $[1] = boundaryElement, $[2] = elementsArg, $[3] = t1) : t1 = $[3];
  const onEvent = useEffectEvent(t1), hasListener = !!listener;
  let t2, t3;
  $[4] !== hasListener || $[5] !== onEvent ? (t2 = () => {
    if (!hasListener)
      return;
    const handleEvent = (evt_0) => onEvent(evt_0);
    return document.addEventListener("mousedown", handleEvent), () => {
      document.removeEventListener("mousedown", handleEvent);
    };
  }, t3 = [hasListener, onEvent], $[4] = hasListener, $[5] = onEvent, $[6] = t2, $[7] = t3) : (t2 = $[6], t3 = $[7]), useEffect(t2, t3), useDebugValue(listener ? "MouseDown On" : "MouseDown Off");
}
function _temp$6() {
  return EMPTY_ARRAY;
}
function useCustomValidity(ref, customValidity) {
  const $ = c(6);
  let t0;
  $[0] !== ref.current || $[1] !== customValidity ? (t0 = () => {
    ref.current?.setCustomValidity(customValidity || "");
  }, $[0] = ref.current, $[1] = customValidity, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== customValidity || $[4] !== ref ? (t1 = [customValidity, ref], $[3] = customValidity, $[4] = ref, $[5] = t1) : t1 = $[5], useEffect(t0, t1);
}
var resizeObservers = [], hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
}, hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
}, msg = "ResizeObserver loop completed with undelivered notifications.", deliverResizeLoopError = function() {
  var event;
  typeof ErrorEvent == "function" ? event = new ErrorEvent("error", {
    message: msg
  }) : (event = document.createEvent("Event"), event.initEvent("error", !1, !1), event.message = msg), window.dispatchEvent(event);
}, ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2.BORDER_BOX = "border-box", ResizeObserverBoxOptions2.CONTENT_BOX = "content-box", ResizeObserverBoxOptions2.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
}, ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize, this.blockSize = blockSize, freeze(this);
  }
  return ResizeObserverSize2;
}(), DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    return this.x = x, this.y = y, this.width = width, this.height = height, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, freeze(this);
  }
  return DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return {
      x,
      y,
      top,
      right,
      bottom,
      left,
      width,
      height
    };
  }, DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }, DOMRectReadOnly2;
}(), isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
}, isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
}, isElement = function(obj) {
  var _a;
  if (obj instanceof Element)
    return !0;
  var scope = (_a = obj?.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
}, isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, global$1 = typeof window < "u" ? window : {}, cache = /* @__PURE__ */ new WeakMap(), scrollRegexp = /auto|scroll/, verticalRegexp = /^tb|vertical/, IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent), parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
}, size$1 = function(inlineSize, blockSize, switchSizes) {
  return inlineSize === void 0 && (inlineSize = 0), blockSize === void 0 && (blockSize = 0), switchSizes === void 0 && (switchSizes = !1), new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
}, zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
}), calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0 && (forceRecalculation = !1), cache.has(target) && !forceRecalculation)
    return cache.get(target);
  if (isHidden(target))
    return cache.set(target, zeroBoxes), zeroBoxes;
  var cs = getComputedStyle(target), svg = isSVG(target) && target.ownerSVGElement && target.getBBox(), removePadding = !IE && cs.boxSizing === "border-box", switchSizes = verticalRegexp.test(cs.writingMode || ""), canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || ""), canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || ""), paddingTop = svg ? 0 : parseDimension(cs.paddingTop), paddingRight = svg ? 0 : parseDimension(cs.paddingRight), paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom), paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft), borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth), borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth), borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth), borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth), horizontalPadding = paddingLeft + paddingRight, verticalPadding = paddingTop + paddingBottom, horizontalBorderArea = borderLeft2 + borderRight2, verticalBorderArea = borderTop2 + borderBottom2, horizontalScrollbarThickness = canScrollHorizontally ? target.offsetHeight - verticalBorderArea - target.clientHeight : 0, verticalScrollbarThickness = canScrollVertically ? target.offsetWidth - horizontalBorderArea - target.clientWidth : 0, widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0, heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0, contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness, contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness, borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea, borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea, boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  return cache.set(target, boxes), boxes;
}, calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
}, ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target, this.contentRect = boxes.contentRect, this.borderBoxSize = freeze([boxes.borderBoxSize]), this.contentBoxSize = freeze([boxes.contentBoxSize]), this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}(), calculateDepthForNode = function(node) {
  if (isHidden(node))
    return 1 / 0;
  for (var depth = 0, parent = node.parentNode; parent; )
    depth += 1, parent = parent.parentNode;
  return depth;
}, broadcastActiveObservations = function() {
  var shallowestDepth = 1 / 0, callbacks2 = [];
  resizeObservers.forEach(function(ro) {
    if (ro.activeTargets.length !== 0) {
      var entries = [];
      ro.activeTargets.forEach(function(ot) {
        var entry = new ResizeObserverEntry(ot.target), targetDepth = calculateDepthForNode(ot.target);
        entries.push(entry), ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox), targetDepth < shallowestDepth && (shallowestDepth = targetDepth);
      }), callbacks2.push(function() {
        ro.callback.call(ro.observer, entries, ro.observer);
      }), ro.activeTargets.splice(0, ro.activeTargets.length);
    }
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
}, gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length), ro.skippedTargets.splice(0, ro.skippedTargets.length), ro.observationTargets.forEach(function(ot) {
      ot.isActive() && (calculateDepthForNode(ot.target) > depth ? ro.activeTargets.push(ot) : ro.skippedTargets.push(ot));
    });
  });
}, process = function() {
  var depth = 0;
  for (gatherActiveObservationsAtDepth(depth); hasActiveObservations(); )
    depth = broadcastActiveObservations(), gatherActiveObservationsAtDepth(depth);
  return hasSkippedObservations() && deliverResizeLoopError(), depth > 0;
}, trigger, callbacks = [], notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
}, queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0, el_1 = document.createTextNode(""), config = {
      characterData: !0
    };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config), trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback), trigger();
}, queueResizeObserver = function(cb) {
  queueMicroTask(function() {
    requestAnimationFrame(cb);
  });
}, watching = 0, isWatching = function() {
  return !!watching;
}, CATCH_PERIOD = 250, observerConfig = {
  attributes: !0,
  characterData: !0,
  childList: !0,
  subtree: !0
}, events = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], time = function(timeout) {
  return timeout === void 0 && (timeout = 0), Date.now() + timeout;
}, scheduled = !1, Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = !0, this.listener = function() {
      return _this.schedule();
    };
  }
  return Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0 && (timeout = CATCH_PERIOD), !scheduled) {
      scheduled = !0;
      var until = time(timeout);
      queueResizeObserver(function() {
        var elementsHaveResized = !1;
        try {
          elementsHaveResized = process();
        } finally {
          if (scheduled = !1, timeout = until - time(), !isWatching())
            return;
          elementsHaveResized ? _this.run(1e3) : timeout > 0 ? _this.run(timeout) : _this.start();
        }
      });
    }
  }, Scheduler2.prototype.schedule = function() {
    this.stop(), this.run();
  }, Scheduler2.prototype.observe = function() {
    var _this = this, cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  }, Scheduler2.prototype.start = function() {
    var _this = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), events.forEach(function(name) {
      return global$1.addEventListener(name, _this.listener, !0);
    }));
  }, Scheduler2.prototype.stop = function() {
    var _this = this;
    this.stopped || (this.observer && this.observer.disconnect(), events.forEach(function(name) {
      return global$1.removeEventListener(name, _this.listener, !0);
    }), this.stopped = !0);
  }, Scheduler2;
}(), scheduler = new Scheduler(), updateCount = function(n) {
  !watching && n > 0 && scheduler.start(), watching += n, !watching && scheduler.stop();
}, skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
}, ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target, this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, !0);
    return skipNotifyOnElement(this.target) && (this.lastReportedSize = size2), this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize;
  }, ResizeObservation2;
}(), ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = resizeObserver, this.callback = callback;
  }
  return ResizeObserverDetail2;
}(), observerMap = /* @__PURE__ */ new WeakMap(), getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1)
    if (observationTargets[i].target === target)
      return i;
  return -1;
}, ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  return ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  }, ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver), firstObservation = detail.observationTargets.length === 0;
    getObservationIndex(detail.observationTargets, target) < 0 && (firstObservation && resizeObservers.push(detail), detail.observationTargets.push(new ResizeObservation(target, options && options.box)), updateCount(1), scheduler.schedule());
  }, ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver), index = getObservationIndex(detail.observationTargets, target), lastObservation = detail.observationTargets.length === 1;
    index >= 0 && (lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1), detail.observationTargets.splice(index, 1), updateCount(-1));
  }, ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this, detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    }), detail.activeTargets.splice(0, detail.activeTargets.length);
  }, ResizeObserverController2;
}(), ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof callback != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    ResizeObserverController.connect(this, callback);
  }
  return ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.observe(this, target, options);
  }, ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.unobserve(this, target);
  }, ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  }, ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, ResizeObserver2;
}();
const _ResizeObserver = typeof document < "u" && typeof window < "u" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver, _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(([entry]) => {
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      return resizeObserver.observe(element), () => {
        resizeObserver.unobserve(element), resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap(), subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      return subscribersCache.has(element) || (subscribersCache.set(element, subscribers), dispose = _createElementRectValueListener().subscribe(element, (elementRect) => {
        for (const sub of subscribers)
          sub(elementRect);
      })), subscribers.push(subscriber), () => {
        const idx = subscribers.indexOf(subscriber);
        idx > -1 && subscribers.splice(idx, 1), subscribers.length === 0 && dispose && dispose();
      };
    }
  };
}
function useElementSize(element) {
  const $ = c(3), [size2, setSize] = useState(null);
  let t0, t1;
  return $[0] !== element ? (t0 = () => {
    if (element)
      return _elementSizeObserver.subscribe(element, setSize);
  }, t1 = [element], $[0] = element, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1), size2;
}
function useElementRect(element) {
  return useElementSize(element)?._contentRect || null;
}
function useForwardedRef(ref) {
  const $ = c(1), innerRef = useRef(null);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => innerRef.current, $[0] = t0) : t0 = $[0], useImperativeHandle(ref, t0), innerRef;
}
function useGlobalKeyDown(onKeyDown) {
  const $ = c(3);
  let t0, t1;
  return $[0] !== onKeyDown ? (t0 = () => (addEventListener("keydown", onKeyDown), () => removeEventListener("keydown", onKeyDown)), t1 = [onKeyDown], $[0] = onKeyDown, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
}
function useMatchMedia(mediaQueryString, getServerSnapshot2) {
  const {
    subscribe: subscribe2,
    getSnapshot
  } = useMemo(() => {
    let MEDIA_QUERY_CACHE;
    const getMatchMedia = () => (MEDIA_QUERY_CACHE || (MEDIA_QUERY_CACHE = window.matchMedia(mediaQueryString)), MEDIA_QUERY_CACHE);
    return {
      subscribe: (onStoreChange) => {
        const matchMedia = getMatchMedia();
        return matchMedia.addEventListener("change", onStoreChange), () => matchMedia.removeEventListener("change", onStoreChange);
      },
      getSnapshot: () => getMatchMedia().matches
    };
  }, [mediaQueryString]);
  return useDebugValue(mediaQueryString), useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot2);
}
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
function createGlobalScopedContext(key2, defaultValue) {
  const symbol = Symbol.for(key2);
  return typeof document > "u" ? createContext(defaultValue) : (globalScope[symbol] = globalScope[symbol] || createContext(defaultValue), globalScope[symbol]);
}
const ThemeContext = createGlobalScopedContext("@sanity/ui/context/theme", null);
function ThemeProvider(props) {
  const $ = c(15), parentTheme = useContext(ThemeContext), {
    children
  } = props, scheme = props.scheme ?? (parentTheme?.scheme || "light"), rootTheme = props.theme ?? (parentTheme?.theme || null), tone = props.tone ?? (parentTheme?.tone || "default");
  let t0;
  bb0: {
    if (!rootTheme) {
      t0 = null;
      break bb0;
    }
    let t12;
    $[0] !== rootTheme || $[1] !== scheme || $[2] !== tone ? (t12 = {
      version: 0,
      theme: rootTheme,
      scheme,
      tone
    }, $[0] = rootTheme, $[1] = scheme, $[2] = tone, $[3] = t12) : t12 = $[3], t0 = t12;
  }
  const themeContext = t0;
  let t1;
  bb1: {
    if (!rootTheme) {
      t1 = null;
      break bb1;
    }
    let t22;
    $[4] !== rootTheme || $[5] !== scheme || $[6] !== tone ? (t22 = getScopedTheme(rootTheme, scheme, tone), $[4] = rootTheme, $[5] = scheme, $[6] = tone, $[7] = t22) : t22 = $[7], t1 = t22;
  }
  const theme = t1;
  if (!theme) {
    let t22;
    return $[8] === Symbol.for("react.memo_cache_sentinel") ? (t22 = /* @__PURE__ */ jsx("pre", { children: 'ThemeProvider: no "theme" property provided' }), $[8] = t22) : t22 = $[8], t22;
  }
  let t2;
  $[9] !== theme || $[10] !== children ? (t2 = /* @__PURE__ */ jsx(ThemeProvider$1, { theme, children }), $[9] = theme, $[10] = children, $[11] = t2) : t2 = $[11];
  let t3;
  return $[12] !== themeContext || $[13] !== t2 ? (t3 = /* @__PURE__ */ jsx(ThemeContext.Provider, { value: themeContext, children: t2 }), $[12] = themeContext, $[13] = t2, $[14] = t3) : t3 = $[14], t3;
}
ThemeProvider.displayName = "ThemeProvider";
function useRootTheme() {
  const value = useContext(ThemeContext);
  if (!value)
    throw new Error("useRootTheme(): missing context value");
  return value;
}
function ThemeColorProvider(props) {
  const $ = c(5), {
    children,
    scheme,
    tone
  } = props, root = useRootTheme(), t0 = scheme || root.scheme;
  let t1;
  return $[0] !== t0 || $[1] !== root.theme || $[2] !== tone || $[3] !== children ? (t1 = /* @__PURE__ */ jsx(ThemeProvider, { scheme: t0, theme: root.theme, tone, children }), $[0] = t0, $[1] = root.theme, $[2] = tone, $[3] = children, $[4] = t1) : t1 = $[4], t1;
}
ThemeColorProvider.displayName = "ThemeColorProvider";
function useTheme() {
  return useTheme$1();
}
function useTheme_v2() {
  const $ = c(2), t0 = useTheme$1();
  let t1;
  return $[0] !== t0 ? (t1 = getTheme_v2(t0), $[0] = t0, $[1] = t1) : t1 = $[1], t1;
}
function _getMediaQuery(media, index) {
  return index === 0 ? `screen and (max-width: ${media[index] - 1}px)` : index === media.length ? `screen and (min-width: ${media[index - 1]}px)` : `screen and (min-width: ${media[index - 1]}px) and (max-width: ${media[index] - 1}px)`;
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({
          index,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  return {
    getSnapshot: () => {
      for (const {
        index,
        mq
      } of getSizes())
        if (mq.matches) return index;
      return 0;
    },
    subscribe: (onStoreChange) => {
      const disposeFns = [];
      for (const {
        mq
      } of getSizes()) {
        const handleChange = () => {
          mq.matches && onStoreChange();
        };
        mq.addEventListener("change", handleChange), disposeFns.push(() => mq.removeEventListener("change", handleChange));
      }
      return () => {
        for (const disposeFn of disposeFns)
          disposeFn();
      };
    }
  };
}
function getServerSnapshot() {
  return 0;
}
function useMediaIndex() {
  const $ = c(2), {
    media
  } = useTheme_v2();
  let t0, t1;
  $[0] !== media ? (t1 = _createMediaStore(media), $[0] = media, $[1] = t1) : t1 = $[1], t0 = t1;
  const store = t0;
  return useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot);
}
function usePrefersDark(t0) {
  return useMatchMedia("(prefers-color-scheme: dark)", t0 === void 0 ? _temp$5 : t0);
}
function _temp$5() {
  return !1;
}
function usePrefersReducedMotion(t0) {
  return useMatchMedia("(prefers-reduced-motion: reduce)", t0 === void 0 ? _temp$4 : t0);
}
function _temp$4() {
  return !1;
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$border, (value) => value ? {
    "&&": {
      border: borderStyle
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderTop, (value) => value ? {
    "&&": {
      borderTop: borderStyle
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderRight, (value) => value ? {
    "&&": {
      borderRight: borderStyle
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderBottom, (value) => value ? {
    "&&": {
      borderBottom: borderStyle
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${card.border?.width ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderLeft, (value) => value ? {
    "&&": {
      borderLeft: borderStyle
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, BOX_SIZING = {
  content: "content-box",
  border: "border-box"
}, BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$display, (display) => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$overflow, (overflow) => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (align) => ({
    alignItems: align
  }));
}
function responsiveFlexGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$wrap, (wrap) => ({
    flexWrap: wrap
  }));
}
function responsiveFlexJustifyStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$justify, (justify) => ({
    justifyContent: justify
  }));
}
function responsiveFlexDirectionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$direction, (direction) => ({
    flexDirection: direction
  }));
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return props.$flex ? _responsive(media, props.$flex, (flex) => ({
    flex
  })) : EMPTY_ARRAY;
}
function focusRingBorderStyle(border2) {
  return `inset 0 0 0 ${border2.width}px ${border2.color}`;
}
function focusRingStyle(opts) {
  const {
    base,
    border: border2,
    focusRing
  } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`, border2 && focusRingBorderStyle(border2), focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`, focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
}, GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columns, (columns) => ({
    gridTemplateColumns: columns && `repeat(${columns},minmax(0,1fr));`
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rows, (rows) => ({
    gridTemplateRows: rows && `repeat(${rows},minmax(0,1fr));`
  }));
}
function responsiveGridGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
}, GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$row, (row) => typeof row == "number" ? {
    gridRow: `span ${row} / span ${row}`
  } : {
    gridRow: GRID_ITEM_ROW[row]
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowEnd, (rowEnd) => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$column, (column) => typeof column == "number" ? {
    gridColumn: `span ${column} / span ${column}`
  } : {
    gridColumn: GRID_ITEM_COLUMN[column]
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space
  } = props, {
    font,
    media,
    space
  } = getTheme_v2(props.theme), len = Math.max($padding.length, $space.length, $fontSize.length), _padding = [], _space = [], _fontSize = [];
  for (let i = 0; i < len; i += 1)
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i], _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i], _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  return _responsive(media, _padding, (_, i) => {
    const size2 = font.text.sizes[_fontSize[i]] || font.text.sizes[2], emSize = size2.lineHeight - size2.ascenderHeight - size2.descenderHeight, p = space[_padding[i]], s = space[_space[i]], styles = {
      paddingTop: rem(p - size2.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size2.descenderHeight),
      paddingLeft: rem(p)
    };
    return $iconRight && (styles.paddingRight = rem(p + emSize + s)), $iconLeft && (styles.paddingLeft = rem(p + emSize + s)), styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: !0
  });
}
const ROOT_STYLE = css`
  &:not([hidden]) {
    display: flex;
  }

  align-items: center;
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    $scheme,
    $tone,
    $weight
  } = props, {
    color,
    font
  } = getTheme_v2(props.theme);
  return css`
    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${$weight && font.text.weights[$weight] || font.text.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;

    /* NOTE: This is a hack to disable Chromeâ€™s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    color: var(--input-fg-color);

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --input-fg-color: ${color.input.default.enabled.fg};
      --input-placeholder-color: ${color.input.default.enabled.placeholder};

      /* enabled */
      &:not(:invalid):not(:disabled):not(:read-only) {
        --input-fg-color: ${color.input.default.enabled.fg};
        --input-placeholder-color: ${color.input.default.enabled.placeholder};
      }

      /* disabled */
      &:not(:invalid):disabled {
        --input-fg-color: ${color.input.default.disabled.fg};
        --input-placeholder-color: ${color.input.default.disabled.placeholder};
      }

      /* invalid */
      &:invalid {
        --input-fg-color: ${color.input.invalid.enabled.fg};
        --input-placeholder-color: ${color.input.invalid.enabled.placeholder};
      }

      /* readOnly */
      &:read-only {
        --input-fg-color: ${color.input.default.readOnly.fg};
        --input-placeholder-color: ${color.input.default.readOnly.placeholder};
      }
    }
  `;
}
function textInputFontSizeStyle(props) {
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$fontSize, (sizeIndex) => {
    const size2 = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size2.fontSize),
      lineHeight: size2.lineHeight / size2.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    $unstableDisableFocusRing
  } = props, {
    color,
    input
  } = getTheme_v2(props.theme);
  return css`
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;

    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --card-bg-color: ${color.input.default.enabled.bg};
      --card-fg-color: ${color.input.default.enabled.fg};

      /* enabled */
      *:not(:disabled) + &[data-border] {
        --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
      }

      /* invalid */
      *:not(:disabled):invalid + & {
        --card-bg-color: ${color.input.invalid.enabled.bg};
        --card-fg-color: ${color.input.invalid.enabled.fg};

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.enabled.border,
    width: input.border.width
  })};
        }
      }

      /* focused */
      *:not(:disabled):focus + & {
        &[data-border] {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: {
      color: color.input.default.enabled.border,
      width: input.border.width
    },
    focusRing: input.text.focusRing
  })};
        }

        &:not([data-border]) {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    focusRing: input.text.focusRing
  })};
        }
      }

      /* disabled */
      *:not(:invalid):disabled + & {
        --card-bg-color: ${color.input.default.disabled.bg} !important;
        --card-fg-color: ${color.input.default.disabled.fg} !important;
        --card-icon-color: ${color.input.default.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  })};
        }
      }

      *:invalid:disabled + & {
        --card-bg-color: ${color.input.invalid.disabled.bg} !important;
        --card-fg-color: ${color.input.invalid.disabled.fg} !important;
        --card-icon-color: ${color.input.invalid.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.disabled.border,
    width: input.border.width
  })};
        }
      }

      /* readOnly */
      *:not(:invalid):read-only + & {
        --card-bg-color: ${color.input.default.readOnly.bg} !important;
        --card-fg-color: ${color.input.default.readOnly.fg} !important;
      }

      *:invalid:read-only + & {
        --card-bg-color: ${color.input.invalid.readOnly.bg} !important;
        --card-fg-color: ${color.input.invalid.readOnly.fg} !important;
      }

      /* hovered */
      @media (hover: hover) {
        *:not(:disabled):not(:read-only):not(:invalid):hover + & {
          --card-bg-color: ${color.input.default.hovered.bg};
          --card-fg-color: ${color.input.default.hovered.fg};
        }

        *:invalid:not(:disabled):not(:read-only):hover + & {
          --card-bg-color: ${color.input.invalid.hovered.bg};
          --card-fg-color: ${color.input.invalid.hovered.fg};
        }

        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
        }

        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color.input.invalid.hovered.border,
    width: input.border.width
  })};
        }
      }
    }
  `;
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    media,
    radius
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$radius, (value) => {
    let borderRadius = 0;
    return typeof value == "number" && (borderRadius = rem(radius[value])), value === "full" && (borderRadius = "9999px"), {
      borderRadius
    };
  });
}
function toBoxShadow(shadow, color) {
  return `${shadow.map(rem).join(" ")} ${color}`;
}
function shadowStyle(shadow, outlineWidth = 1) {
  if (!shadow) return EMPTY_RECORD;
  const outline = `0 0 0 ${rem(outlineWidth)} var(--card-shadow-outline-color)`, umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)"), penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)"), ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: `${outline}, ${umbra}, ${penumbra}, ${ambient}`
  };
}
function responsiveShadowStyle(props) {
  const {
    card,
    media,
    shadow
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$shadow, (index) => shadowStyle(shadow[index], card.shadow.outline));
}
function labelBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return css`
    text-transform: uppercase;

    ${$accent && css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$C = styled.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle), SpanWithTextOverflow$2 = styled.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Label = forwardRef(function(props, ref) {
  const $ = c(22);
  let t0, t1, childrenProp, textOverflow, align, restProps, accent, weight;
  $[0] !== props ? ({
    accent,
    align,
    children: childrenProp,
    muted: t0,
    size: t1,
    textOverflow,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = childrenProp, $[4] = textOverflow, $[5] = align, $[6] = restProps, $[7] = accent, $[8] = weight) : (t0 = $[1], t1 = $[2], childrenProp = $[3], textOverflow = $[4], align = $[5], restProps = $[6], accent = $[7], weight = $[8]);
  const muted = t0 === void 0 ? !1 : t0, size2 = t1 === void 0 ? 2 : t1;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t22;
    $[9] !== children ? (t22 = /* @__PURE__ */ jsx(SpanWithTextOverflow$2, { children }), $[9] = children, $[10] = t22) : t22 = $[10], children = t22;
  } else {
    let t22;
    $[11] !== children ? (t22 = /* @__PURE__ */ jsx("span", { children }), $[11] = children, $[12] = t22) : t22 = $[12], children = t22;
  }
  const t2 = useArrayProp(align), t3 = useArrayProp(size2);
  let t4;
  return $[13] !== restProps || $[14] !== accent || $[15] !== t2 || $[16] !== muted || $[17] !== t3 || $[18] !== weight || $[19] !== ref || $[20] !== children ? (t4 = /* @__PURE__ */ jsx(Root$C, { "data-ui": "Label", ...restProps, $accent: accent, $align: t2, $muted: muted, $size: t3, $weight: weight, ref, children }), $[13] = restProps, $[14] = accent, $[15] = t2, $[16] = muted, $[17] = t3, $[18] = weight, $[19] = ref, $[20] = children, $[21] = t4) : t4 = $[21], t4;
});
Label.displayName = "ForwardRef(Label)";
const avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color
  } = props, {
    avatar
  } = getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": `var(--card-avatar-${$color}-bg-color)`,
    "--avatar-fg-color": `var(--card-avatar-${$color}-fg-color)`,
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing: avatar.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$B = styled.div(responsiveAvatarSizeStyle, avatarStyle.root), Arrow$1 = styled.div(avatarStyle.arrow), BgStroke = styled.ellipse(avatarStyle.bgStroke), Stroke = styled.ellipse(avatarStyle.stroke), Initials = styled.div(avatarStyle.initials), InitialsLabel = styled(Label)({
  color: "inherit"
}), Image = styled.svg(avatarStyle.image), Avatar = forwardRef(function(props, ref) {
  const $ = c(53);
  let t0, t1, t2, asProp, animateArrowFrom, arrowPositionProp, src, onImageLoadError, __unstable_hideInnerStroke, initials, restProps, title;
  $[0] !== props ? ({
    __unstable_hideInnerStroke,
    as: asProp,
    color: t0,
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status: t1,
    size: t2,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = asProp, $[5] = animateArrowFrom, $[6] = arrowPositionProp, $[7] = src, $[8] = onImageLoadError, $[9] = __unstable_hideInnerStroke, $[10] = initials, $[11] = restProps, $[12] = title) : (t0 = $[1], t1 = $[2], t2 = $[3], asProp = $[4], animateArrowFrom = $[5], arrowPositionProp = $[6], src = $[7], onImageLoadError = $[8], __unstable_hideInnerStroke = $[9], initials = $[10], restProps = $[11], title = $[12]);
  const color = t0 === void 0 ? "gray" : t0, status = t1 === void 0 ? "online" : t1, sizeProp = t2 === void 0 ? 1 : t2, {
    avatar
  } = useTheme_v2(), as = ReactIs.isValidElementType(asProp) ? asProp : "div", size2 = useArrayProp(sizeProp), _sizeRem = (avatar.sizes[size2[0]] || avatar.sizes[0]).size, _radius = _sizeRem / 2, elementId = useId(), [arrowPosition, setArrowPosition] = useState(animateArrowFrom || arrowPositionProp || "inside"), [imageFailed, setImageFailed] = useState(!1), imageId = `avatar-image-${elementId}`;
  let t3, t4;
  $[13] !== arrowPosition || $[14] !== arrowPositionProp ? (t3 = () => {
    if (arrowPosition === arrowPositionProp)
      return;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, t4 = [arrowPosition, arrowPositionProp], $[13] = arrowPosition, $[14] = arrowPositionProp, $[15] = t3, $[16] = t4) : (t3 = $[15], t4 = $[16]), useEffect(t3, t4);
  let t5, t6;
  $[17] !== src ? (t5 = () => {
    src && setImageFailed(!1);
  }, t6 = [src], $[17] = src, $[18] = t5, $[19] = t6) : (t5 = $[18], t6 = $[19]), useEffect(t5, t6);
  let t7;
  $[20] !== onImageLoadError ? (t7 = () => {
    setImageFailed(!0), onImageLoadError && onImageLoadError(new Error("Avatar: the image failed to load"));
  }, $[20] = onImageLoadError, $[21] = t7) : t7 = $[21];
  const handleImageError = t7;
  let t8, t9;
  if ($[22] !== size2) {
    let t102;
    $[24] === Symbol.for("react.memo_cache_sentinel") ? (t102 = (s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0, $[24] = t102) : t102 = $[24], t9 = size2.map(t102), $[22] = size2, $[23] = t9;
  } else
    t9 = $[23];
  t8 = t9;
  const initialsSize = t8, t10 = typeof as == "string" ? as : void 0;
  let t11;
  $[25] !== color ? (t11 = /* @__PURE__ */ jsx(Arrow$1, { children: /* @__PURE__ */ jsx("svg", { width: "11", height: "7", viewBox: "0 0 11 7", fill: "none", children: /* @__PURE__ */ jsx("path", { d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z", fill: color }) }) }), $[25] = color, $[26] = t11) : t11 = $[26];
  let t12;
  $[27] !== imageFailed || $[28] !== src || $[29] !== _sizeRem || $[30] !== handleImageError || $[31] !== imageId || $[32] !== _radius || $[33] !== __unstable_hideInnerStroke ? (t12 = !imageFailed && src && /* @__PURE__ */ jsxs(Image, { viewBox: `0 0 ${_sizeRem} ${_sizeRem}`, fill: "none", children: [
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("pattern", { id: imageId, patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsx("image", { href: src, width: "1", height: "1", onError: handleImageError }) }) }),
    /* @__PURE__ */ jsx("circle", { cx: _radius, cy: _radius, r: _radius, fill: `url(#${imageId})` }),
    !__unstable_hideInnerStroke && /* @__PURE__ */ jsx(BgStroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" }),
    /* @__PURE__ */ jsx(Stroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" })
  ] }), $[27] = imageFailed, $[28] = src, $[29] = _sizeRem, $[30] = handleImageError, $[31] = imageId, $[32] = _radius, $[33] = __unstable_hideInnerStroke, $[34] = t12) : t12 = $[34];
  let t13;
  $[35] !== imageFailed || $[36] !== src || $[37] !== initials || $[38] !== initialsSize ? (t13 = (imageFailed || !src) && initials && /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(Initials, { children: /* @__PURE__ */ jsx(InitialsLabel, { forwardedAs: "span", size: initialsSize, weight: "medium", children: initials }) }) }), $[35] = imageFailed, $[36] = src, $[37] = initials, $[38] = initialsSize, $[39] = t13) : t13 = $[39];
  let t14;
  return $[40] !== as || $[41] !== t10 || $[42] !== restProps || $[43] !== color || $[44] !== size2 || $[45] !== title || $[46] !== arrowPosition || $[47] !== status || $[48] !== ref || $[49] !== t11 || $[50] !== t12 || $[51] !== t13 ? (t14 = /* @__PURE__ */ jsxs(Root$B, { as, "data-as": t10, "data-ui": "Avatar", ...restProps, $color: color, $size: size2, "aria-label": title, "data-arrow-position": arrowPosition, "data-status": status, ref, title, children: [
    t11,
    t12,
    t13
  ] }), $[40] = as, $[41] = t10, $[42] = restProps, $[43] = color, $[44] = size2, $[45] = title, $[46] = arrowPosition, $[47] = status, $[48] = ref, $[49] = t11, $[50] = t12, $[51] = t13, $[52] = t14) : t14 = $[52], t14;
});
Avatar.displayName = "ForwardRef(Avatar)";
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    } : EMPTY_RECORD;
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    space
  } = getTheme_v2(props.theme);
  return css`
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    user-select: none;
    color: inherit;
    color: var(--card-fg-color);
    background: var(--card-bg-color);
    box-shadow:
      0 0 0 1px var(--card-bg-color),
      inset 0 0 0 1px var(--card-hairline-hard-color);
    padding: 0 ${rem(space[2])};

    &:not([hidden]) {
      display: flex;
    }
  `;
}
const Root$A = styled.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle), AvatarCounter = forwardRef(function(props, ref) {
  const $ = c(10), {
    count,
    size: t0
  } = props, size2 = useArrayProp(t0 === void 0 ? 1 : t0);
  let t1, t2;
  if ($[0] !== size2) {
    let t32;
    $[2] === Symbol.for("react.memo_cache_sentinel") ? (t32 = (s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0, $[2] = t32) : t32 = $[2], t2 = size2.map(t32), $[0] = size2, $[1] = t2;
  } else
    t2 = $[1];
  t1 = t2;
  const fontSize2 = t1;
  let t3;
  $[3] !== fontSize2 || $[4] !== count ? (t3 = /* @__PURE__ */ jsx(Label, { as: "span", size: fontSize2, weight: "medium", children: count }), $[3] = fontSize2, $[4] = count, $[5] = t3) : t3 = $[5];
  let t4;
  return $[6] !== size2 || $[7] !== ref || $[8] !== t3 ? (t4 = /* @__PURE__ */ jsx(Root$A, { $size: size2, "data-ui": "AvatarCounter", ref, children: t3 }), $[6] = size2, $[7] = ref, $[8] = t3, $[9] = t4) : t4 = $[9], t4;
});
AvatarCounter.displayName = "ForwardRef(AvatarCounter)";
const BASE_STYLES = css`
  white-space: nowrap;

  & > div {
    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  }
`;
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    } : EMPTY_RECORD;
  });
}
const Root$z = styled.div(responsiveAvatarStackSizeStyle, avatarStackStyle), AvatarStack = forwardRef(function(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 1,
    ...restProps
  } = props, children = useMemo(() => Children.toArray(childrenProp).filter(isValidElement), [childrenProp]), maxLength = Math.max(maxLengthProp, 0), size2 = useArrayProp(sizeProp), len = children.length, visibleCount = maxLength - 1, extraCount = len - visibleCount, visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */ jsxs(Root$z, { "data-ui": "AvatarStack", ...restProps, ref, $size: size2, children: [
    len === 0 && /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(AvatarCounter, { count: len, size: size2 }) }),
    len !== 0 && extraCount > 1 && /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(AvatarCounter, { count: extraCount, size: size2 }) }),
    visibleChildren.map((child, childIndex) => /* @__PURE__ */ jsx("div", { children: cloneElement(child, {
      size: size2
    }) }, String(childIndex)))
  ] });
});
AvatarStack.displayName = "ForwardRef(AvatarStack)";
const Root$y = styled.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle), Box = forwardRef(function(props, ref) {
  const $ = c(59);
  let t0, t1, t2, t3, column, columnStart, columnEnd, flex, height, marginX, marginY, marginTop, marginRight, marginBottom, marginLeft, overflow, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft, row, rowStart, rowEnd, sizing, restProps;
  $[0] !== props ? ({
    as: t0,
    column,
    columnStart,
    columnEnd,
    display: t1,
    flex,
    height,
    margin: t2,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding: t3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = column, $[6] = columnStart, $[7] = columnEnd, $[8] = flex, $[9] = height, $[10] = marginX, $[11] = marginY, $[12] = marginTop, $[13] = marginRight, $[14] = marginBottom, $[15] = marginLeft, $[16] = overflow, $[17] = paddingX, $[18] = paddingY, $[19] = paddingTop, $[20] = paddingRight, $[21] = paddingBottom, $[22] = paddingLeft, $[23] = row, $[24] = rowStart, $[25] = rowEnd, $[26] = sizing, $[27] = restProps) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], column = $[5], columnStart = $[6], columnEnd = $[7], flex = $[8], height = $[9], marginX = $[10], marginY = $[11], marginTop = $[12], marginRight = $[13], marginBottom = $[14], marginLeft = $[15], overflow = $[16], paddingX = $[17], paddingY = $[18], paddingTop = $[19], paddingRight = $[20], paddingBottom = $[21], paddingLeft = $[22], row = $[23], rowStart = $[24], rowEnd = $[25], sizing = $[26], restProps = $[27]);
  const asProp = t0 === void 0 ? "div" : t0, display = t1 === void 0 ? "block" : t1, margin = t2 === void 0 ? 0 : t2, padding = t3 === void 0 ? 0 : t3, t4 = typeof asProp == "string" ? asProp : void 0, t5 = useArrayProp(column), t6 = useArrayProp(columnStart), t7 = useArrayProp(columnEnd), t8 = useArrayProp(display), t9 = useArrayProp(flex), t10 = useArrayProp(height), t11 = useArrayProp(margin), t12 = useArrayProp(marginX), t13 = useArrayProp(marginY), t14 = useArrayProp(marginTop), t15 = useArrayProp(marginRight), t16 = useArrayProp(marginBottom), t17 = useArrayProp(marginLeft), t18 = useArrayProp(overflow), t19 = useArrayProp(padding), t20 = useArrayProp(paddingX), t21 = useArrayProp(paddingY), t22 = useArrayProp(paddingTop), t23 = useArrayProp(paddingRight), t24 = useArrayProp(paddingBottom), t25 = useArrayProp(paddingLeft), t26 = useArrayProp(row), t27 = useArrayProp(rowStart), t28 = useArrayProp(rowEnd), t29 = useArrayProp(sizing);
  let t30;
  return $[28] !== t4 || $[29] !== restProps || $[30] !== t5 || $[31] !== t6 || $[32] !== t7 || $[33] !== t8 || $[34] !== t9 || $[35] !== t10 || $[36] !== t11 || $[37] !== t12 || $[38] !== t13 || $[39] !== t14 || $[40] !== t15 || $[41] !== t16 || $[42] !== t17 || $[43] !== t18 || $[44] !== t19 || $[45] !== t20 || $[46] !== t21 || $[47] !== t22 || $[48] !== t23 || $[49] !== t24 || $[50] !== t25 || $[51] !== t26 || $[52] !== t27 || $[53] !== t28 || $[54] !== t29 || $[55] !== asProp || $[56] !== ref || $[57] !== props.children ? (t30 = /* @__PURE__ */ jsx(Root$y, { "data-as": t4, "data-ui": "Box", ...restProps, $column: t5, $columnStart: t6, $columnEnd: t7, $display: t8, $flex: t9, $height: t10, $margin: t11, $marginX: t12, $marginY: t13, $marginTop: t14, $marginRight: t15, $marginBottom: t16, $marginLeft: t17, $overflow: t18, $padding: t19, $paddingX: t20, $paddingY: t21, $paddingTop: t22, $paddingRight: t23, $paddingBottom: t24, $paddingLeft: t25, $row: t26, $rowStart: t27, $rowEnd: t28, $sizing: t29, as: asProp, ref, children: props.children }), $[28] = t4, $[29] = restProps, $[30] = t5, $[31] = t6, $[32] = t7, $[33] = t8, $[34] = t9, $[35] = t10, $[36] = t11, $[37] = t12, $[38] = t13, $[39] = t14, $[40] = t15, $[41] = t16, $[42] = t17, $[43] = t18, $[44] = t19, $[45] = t20, $[46] = t21, $[47] = t22, $[48] = t23, $[49] = t24, $[50] = t25, $[51] = t26, $[52] = t27, $[53] = t28, $[54] = t29, $[55] = asProp, $[56] = ref, $[57] = props.children, $[58] = t30) : t30 = $[58], t30;
});
Box.displayName = "ForwardRef(Box)";
function textBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return css`
    color: var(--card-fg-color);

    ${$accent && css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
      background-color: var(--card-code-bg-color);
      color: var(--card-code-fg-color);
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.text.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
      color: var(--card-icon-color);

      & path {
        vector-effect: non-scaling-stroke !important;
      }
    }
  `;
}
const Root$x = styled.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle), SpanWithTextOverflow$1 = styled.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Text = forwardRef(function(props, ref) {
  const $ = c(22);
  let t0, t1, t2, childrenProp, textOverflow, align, restProps, weight;
  $[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t2,
    textOverflow,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = childrenProp, $[5] = textOverflow, $[6] = align, $[7] = restProps, $[8] = weight) : (t0 = $[1], t1 = $[2], t2 = $[3], childrenProp = $[4], textOverflow = $[5], align = $[6], restProps = $[7], weight = $[8]);
  const accent = t0 === void 0 ? !1 : t0, muted = t1 === void 0 ? !1 : t1, size2 = t2 === void 0 ? 2 : t2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $[9] !== children ? (t32 = /* @__PURE__ */ jsx(SpanWithTextOverflow$1, { children }), $[9] = children, $[10] = t32) : t32 = $[10], children = t32;
  }
  const t3 = useArrayProp(align), t4 = useArrayProp(size2);
  let t5;
  $[11] !== children ? (t5 = /* @__PURE__ */ jsx("span", { children }), $[11] = children, $[12] = t5) : t5 = $[12];
  let t6;
  return $[13] !== restProps || $[14] !== accent || $[15] !== t3 || $[16] !== muted || $[17] !== ref || $[18] !== t4 || $[19] !== weight || $[20] !== t5 ? (t6 = /* @__PURE__ */ jsx(Root$x, { "data-ui": "Text", ...restProps, $accent: accent, $align: t3, $muted: muted, ref, $size: t4, $weight: weight, children: t5 }), $[13] = restProps, $[14] = accent, $[15] = t3, $[16] = muted, $[17] = ref, $[18] = t4, $[19] = weight, $[20] = t5, $[21] = t6) : t6 = $[21], t6;
});
Text.displayName = "ForwardRef(Text)";
function badgeStyle(props) {
  const {
    $tone
  } = props;
  return {
    "--card-bg-color": `var(--card-badge-${$tone}-bg-color)`,
    "--card-fg-color": `var(--card-badge-${$tone}-fg-color)`,
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
const Root$w = styled(Box)(responsiveRadiusStyle, badgeStyle), Badge = forwardRef(function(props, ref) {
  const $ = c(17);
  let t0, t1, t2, t3, children, restProps;
  if ($[0] !== props) {
    const {
      children: t42,
      fontSize: t52,
      mode: _deprecated_mode,
      padding: t62,
      radius: t72,
      tone: t8,
      ...t9
    } = props;
    children = t42, t0 = t52, t1 = t62, t2 = t72, t3 = t8, restProps = t9, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = children, $[6] = restProps;
  } else
    t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], children = $[5], restProps = $[6];
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 1 : t1, radius = t2 === void 0 ? "full" : t2, tone = t3 === void 0 ? "default" : t3, t4 = useArrayProp(radius), t5 = useArrayProp(padding);
  let t6;
  $[7] !== fontSize2 || $[8] !== children ? (t6 = /* @__PURE__ */ jsx(Text, { size: fontSize2, children }), $[7] = fontSize2, $[8] = children, $[9] = t6) : t6 = $[9];
  let t7;
  return $[10] !== restProps || $[11] !== tone || $[12] !== t4 || $[13] !== t5 || $[14] !== ref || $[15] !== t6 ? (t7 = /* @__PURE__ */ jsx(Root$w, { "data-ui": "Badge", ...restProps, $tone: tone, $radius: t4, padding: t5, ref, children: t6 }), $[10] = restProps, $[11] = tone, $[12] = t4, $[13] = t5, $[14] = ref, $[15] = t6, $[16] = t7) : t7 = $[16], t7;
});
Badge.displayName = "ForwardRef(Badge)";
const Root$v = styled(Box)(flexItemStyle, responsiveFlexStyle), Flex = forwardRef(function(props, ref) {
  const $ = c(17);
  let t0, align, gap, justify, wrap, restProps, as;
  $[0] !== props ? ({
    align,
    as,
    direction: t0,
    gap,
    justify,
    wrap,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = align, $[3] = gap, $[4] = justify, $[5] = wrap, $[6] = restProps, $[7] = as) : (t0 = $[1], align = $[2], gap = $[3], justify = $[4], wrap = $[5], restProps = $[6], as = $[7]);
  const direction = t0 === void 0 ? "row" : t0, t1 = useArrayProp(align), t2 = useArrayProp(direction), t3 = useArrayProp(gap), t4 = useArrayProp(justify), t5 = useArrayProp(wrap);
  let t6;
  return $[8] !== restProps || $[9] !== t1 || $[10] !== t2 || $[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== as || $[15] !== ref ? (t6 = /* @__PURE__ */ jsx(Root$v, { "data-ui": "Flex", ...restProps, $align: t1, $direction: t2, $gap: t3, $justify: t4, $wrap: t5, forwardedAs: as, ref }), $[8] = restProps, $[9] = t1, $[10] = t2, $[11] = t3, $[12] = t4, $[13] = t5, $[14] = as, $[15] = ref, $[16] = t6) : t6 = $[16], t6;
});
Flex.displayName = "ForwardRef(Flex)";
const rotate$1 = keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, Root$u = styled(Text)`
  & > span > svg {
    animation: ${rotate$1} 500ms linear infinite;
  }
`, Spinner = forwardRef(function(props, ref) {
  const $ = c(4);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx(SpinnerIcon, {}), $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props || $[2] !== ref ? (t1 = /* @__PURE__ */ jsx(Root$u, { "data-ui": "Spinner", ...props, ref, children: t0 }), $[1] = props, $[2] = ref, $[3] = t1) : t1 = $[3], t1;
});
Spinner.displayName = "ForwardRef(Spinner)";
function _cardColorStyle(base, color, checkered = !1) {
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color.accent.fg,
    "--card-avatar-gray-bg-color": color.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color.avatar.red.bg,
    "--card-avatar-red-fg-color": color.avatar.red.fg,
    "--card-avatar-orange-bg-color": color.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color.avatar.green.bg,
    "--card-avatar-green-fg-color": color.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color.avatar.cyan.fg,
    "--card-bg-color": color.bg,
    "--card-bg-image": checkered ? `repeating-conic-gradient(${color.bg} 0% 25%, ${color.muted.bg} 0% 50%)` : void 0,
    "--card-border-color": color.border,
    "--card-badge-default-bg-color": color.badge.default.bg,
    "--card-badge-default-dot-color": color.badge.default.dot,
    "--card-badge-default-fg-color": color.badge.default.fg,
    "--card-badge-default-icon-color": color.badge.default.icon,
    "--card-badge-primary-bg-color": color.badge.primary.bg,
    "--card-badge-primary-dot-color": color.badge.primary.dot,
    "--card-badge-primary-fg-color": color.badge.primary.fg,
    "--card-badge-primary-icon-color": color.badge.primary.icon,
    "--card-badge-positive-bg-color": color.badge.positive.bg,
    "--card-badge-positive-dot-color": color.badge.positive.dot,
    "--card-badge-positive-fg-color": color.badge.positive.fg,
    "--card-badge-positive-icon-color": color.badge.positive.icon,
    "--card-badge-caution-bg-color": color.badge.caution.bg,
    "--card-badge-caution-dot-color": color.badge.caution.dot,
    "--card-badge-caution-fg-color": color.badge.caution.fg,
    "--card-badge-caution-icon-color": color.badge.caution.icon,
    "--card-badge-critical-bg-color": color.badge.critical.bg,
    "--card-badge-critical-dot-color": color.badge.critical.dot,
    "--card-badge-critical-fg-color": color.badge.critical.fg,
    "--card-badge-critical-icon-color": color.badge.critical.icon,
    "--card-code-bg-color": color.code.bg,
    "--card-code-fg-color": color.code.fg,
    "--card-fg-color": color.fg,
    "--card-icon-color": color.icon,
    "--card-kbd-bg-color": color.kbd.bg,
    "--card-kbd-border-color": color.kbd.border,
    "--card-kbd-fg-color": color.kbd.fg,
    "--card-link-fg-color": color.link.fg,
    "--card-muted-bg-color": color.muted.bg,
    "--card-muted-fg-color": color.muted.fg,
    "--card-skeleton-color-from": color.skeleton.from,
    "--card-skeleton-color-to": color.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color.muted.bg,
    "--card-link-color": color.link.fg,
    "--card-hairline-soft-color": color.border,
    "--card-hairline-hard-color": color.border
  };
}
function buttonBaseStyles(props) {
  const {
    $width
  } = props, {
    style
  } = getTheme_v2(props.theme);
  return css`
    ${style?.button};

    -webkit-font-smoothing: inherit;
    appearance: none;
    display: inline-flex;
    align-items: center;
    font: inherit;
    border: 0;
    outline: none;
    user-select: none;
    text-decoration: none;
    border: 0;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    white-space: nowrap;
    text-align: left;
    position: relative;
    vertical-align: top;

    ${$width === "fill" && css`
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    `}

    & > span {
      display: block;
      flex: 1;
      min-width: 0;
      border-radius: inherit;
    }

    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  `;
}
function combineBoxShadow(...boxShadows) {
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  const {
    $mode
  } = props, {
    button,
    color: baseColor,
    style
  } = getTheme_v2(props.theme), shadow = props.$mode === "ghost", mode = baseColor.button[$mode] || baseColor.button.default, color = mode[props.$tone] || mode.default, border2 = {
    width: button.border.width,
    color: "var(--card-border-color)"
  }, defaultBoxShadow = void 0;
  return [_cardColorStyle(baseColor, color.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border2),
    '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color.disabled),
    "&:not([data-disabled='true'])": {
      boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0),
      "&:focus": {
        boxShadow: focusRingStyle({
          base: baseColor,
          border: {
            width: 2,
            color: baseColor.bg
          },
          focusRing: button.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0)
      },
      "@media (hover: hover)": {
        "&:hover": _cardColorStyle(baseColor, color.hovered),
        "&:active": _cardColorStyle(baseColor, color.pressed),
        "&[data-hovered]": _cardColorStyle(baseColor, color.hovered)
      },
      "&[data-selected]": _cardColorStyle(baseColor, color.pressed)
    }
  }, style?.button?.root].filter(Boolean);
}
const Root$t = styled.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles), LoadingBox = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--card-bg-color);
  border-radius: inherit;
  z-index: 1;
  box-shadow: inherit;
`, Button = forwardRef(function(props, ref) {
  const $ = c(64);
  let t0, t1, t2, t3, t4, t5, t6, t7, t8, paddingXProp, paddingYProp, paddingTopProp, paddingBottomProp, paddingLeftProp, paddingRightProp, loading, disabled, selected, IconComponent, text, IconRightComponent, textAlign, children, restProps, width;
  $[0] !== props ? ({
    children,
    disabled,
    fontSize: t0,
    icon: IconComponent,
    iconRight: IconRightComponent,
    justify: t1,
    loading,
    mode: t2,
    padding: t3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: t4,
    selected,
    space: t5,
    text,
    textAlign,
    tone: t6,
    type: t7,
    muted: t8,
    width,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = t5, $[7] = t6, $[8] = t7, $[9] = t8, $[10] = paddingXProp, $[11] = paddingYProp, $[12] = paddingTopProp, $[13] = paddingBottomProp, $[14] = paddingLeftProp, $[15] = paddingRightProp, $[16] = loading, $[17] = disabled, $[18] = selected, $[19] = IconComponent, $[20] = text, $[21] = IconRightComponent, $[22] = textAlign, $[23] = children, $[24] = restProps, $[25] = width) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], t5 = $[6], t6 = $[7], t7 = $[8], t8 = $[9], paddingXProp = $[10], paddingYProp = $[11], paddingTopProp = $[12], paddingBottomProp = $[13], paddingLeftProp = $[14], paddingRightProp = $[15], loading = $[16], disabled = $[17], selected = $[18], IconComponent = $[19], text = $[20], IconRightComponent = $[21], textAlign = $[22], children = $[23], restProps = $[24], width = $[25]);
  const fontSize2 = t0 === void 0 ? 1 : t0, justifyProp = t1 === void 0 ? "center" : t1, mode = t2 === void 0 ? "default" : t2, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, tone = t6 === void 0 ? "default" : t6, type = t7 === void 0 ? "button" : t7, muted = t8 === void 0 ? !1 : t8, {
    button
  } = useTheme_v2(), justify = useArrayProp(justifyProp), padding = useArrayProp(paddingProp), paddingX = useArrayProp(paddingXProp), paddingY = useArrayProp(paddingYProp), paddingTop = useArrayProp(paddingTopProp), paddingBottom = useArrayProp(paddingBottomProp), paddingLeft = useArrayProp(paddingLeftProp), paddingRight = useArrayProp(paddingRightProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp);
  let t9, t10;
  $[26] !== padding || $[27] !== paddingX || $[28] !== paddingY || $[29] !== paddingTop || $[30] !== paddingBottom || $[31] !== paddingLeft || $[32] !== paddingRight ? (t10 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }, $[26] = padding, $[27] = paddingX, $[28] = paddingY, $[29] = paddingTop, $[30] = paddingBottom, $[31] = paddingLeft, $[32] = paddingRight, $[33] = t10) : t10 = $[33], t9 = t10;
  const boxProps = t9, t11 = !!(loading || disabled), t12 = selected ? "" : void 0, t13 = !!(loading || disabled);
  let t14;
  $[34] !== loading ? (t14 = !!loading && /* @__PURE__ */ jsx(LoadingBox, { children: /* @__PURE__ */ jsx(Spinner, {}) }), $[34] = loading, $[35] = t14) : t14 = $[35];
  let t15;
  $[36] !== IconComponent || $[37] !== text || $[38] !== IconRightComponent || $[39] !== fontSize2 || $[40] !== muted || $[41] !== textAlign || $[42] !== button || $[43] !== justify || $[44] !== space || $[45] !== boxProps ? (t15 = (IconComponent || text || IconRightComponent) && /* @__PURE__ */ jsx(Box, { as: "span", ...boxProps, children: /* @__PURE__ */ jsxs(Flex, { as: "span", justify, gap: space, children: [
    IconComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
      isValidElement(IconComponent) && IconComponent,
      isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
    ] }),
    text && /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { muted, align: textAlign, size: fontSize2, textOverflow: "ellipsis", weight: button.textWeight, children: text }) }),
    IconRightComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
      isValidElement(IconRightComponent) && IconRightComponent,
      isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
    ] })
  ] }) }), $[36] = IconComponent, $[37] = text, $[38] = IconRightComponent, $[39] = fontSize2, $[40] = muted, $[41] = textAlign, $[42] = button, $[43] = justify, $[44] = space, $[45] = boxProps, $[46] = t15) : t15 = $[46];
  let t16;
  $[47] !== children || $[48] !== boxProps ? (t16 = children && /* @__PURE__ */ jsx(Box, { as: "span", ...boxProps, children }), $[47] = children, $[48] = boxProps, $[49] = t16) : t16 = $[49];
  let t17;
  return $[50] !== restProps || $[51] !== mode || $[52] !== radius || $[53] !== tone || $[54] !== t11 || $[55] !== t12 || $[56] !== t13 || $[57] !== ref || $[58] !== type || $[59] !== width || $[60] !== t14 || $[61] !== t15 || $[62] !== t16 ? (t17 = /* @__PURE__ */ jsxs(Root$t, { "data-ui": "Button", ...restProps, $mode: mode, $radius: radius, $tone: tone, "data-disabled": t11, "data-selected": t12, disabled: t13, ref, type, $width: width, children: [
    t14,
    t15,
    t16
  ] }), $[50] = restProps, $[51] = mode, $[52] = radius, $[53] = tone, $[54] = t11, $[55] = t12, $[56] = t13, $[57] = ref, $[58] = type, $[59] = width, $[60] = t14, $[61] = t15, $[62] = t16, $[63] = t17) : t17 = $[63], t17;
});
Button.displayName = "ForwardRef(Button)";
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return css`
    ${$checkered && css`
      background-size: ${space[3]}px ${space[3]}px;
      background-position: 50% 50%;
      background-image: var(--card-bg-image);
    `}

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      outline: none;
      text-decoration: none;
    }

    /* &:is(pre) */
    &[data-as='pre'] {
      font: inherit;
    }
  `;
}
function cardColorStyle(props) {
  const {
    $checkered,
    $focusRing,
    $muted
  } = props, {
    card,
    color,
    style
  } = getTheme_v2(props.theme), border2 = {
    width: card.border.width,
    color: "var(--card-border-color)"
  };
  return css`
    color-scheme: ${color._dark ? "dark" : "light"};

    ${_cardColorStyle(color, color, $checkered)}

    background-color: ${$muted ? "var(--card-muted-bg-color)" : "var(--card-bg-color)"};
    color: var(--card-fg-color);

    /* &:is(button) */
    &[data-as='button'] {
      --card-focus-ring-box-shadow: none;

      cursor: default;
      box-shadow: var(--card-focus-ring-box-shadow);

      &:disabled {
        ${_cardColorStyle(color, color.selectable.default.disabled, $checkered)}
      }

      &:not(:disabled) {
        &[data-pressed] {
          ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, color.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, color.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      cursor: pointer;
      box-shadow: var(--card-focus-ring-box-shadow);

      &[data-disabled] {
        ${_cardColorStyle(color, color.selectable.default.disabled, $checkered)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, color.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, color.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color, color.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    ${style?.card?.root}
  `;
}
const Root$s = styled(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle), Card = forwardRef(function(props, ref) {
  const $ = c(42);
  let t0, t1, t2, t3, asProp, border2, borderTop2, borderRight2, borderBottom2, borderLeft2, shadow, pressed, selected, restProps, muted, scheme;
  $[0] !== props ? ({
    __unstable_checkered: t0,
    __unstable_focusRing: t1,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    muted,
    pressed,
    radius: t2,
    scheme,
    selected,
    shadow,
    tone: t3,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = asProp, $[6] = border2, $[7] = borderTop2, $[8] = borderRight2, $[9] = borderBottom2, $[10] = borderLeft2, $[11] = shadow, $[12] = pressed, $[13] = selected, $[14] = restProps, $[15] = muted, $[16] = scheme) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], asProp = $[5], border2 = $[6], borderTop2 = $[7], borderRight2 = $[8], borderBottom2 = $[9], borderLeft2 = $[10], shadow = $[11], pressed = $[12], selected = $[13], restProps = $[14], muted = $[15], scheme = $[16]);
  const checkered = t0 === void 0 ? !1 : t0, focusRing = t1 === void 0 ? !1 : t1, radius = t2 === void 0 ? 0 : t2, toneProp = t3 === void 0 ? "default" : t3, as = isValidElementType(asProp) ? asProp : "div", rootTheme = useRootTheme(), tone = toneProp === "inherit" ? rootTheme.tone : toneProp, t4 = typeof as == "string" ? as : void 0, t5 = rootTheme.scheme, t6 = useArrayProp(border2), t7 = useArrayProp(borderTop2), t8 = useArrayProp(borderRight2), t9 = useArrayProp(borderBottom2), t10 = useArrayProp(borderLeft2), t11 = useArrayProp(radius), t12 = useArrayProp(shadow), t13 = checkered ? "" : void 0, t14 = pressed ? "" : void 0, t15 = selected ? "" : void 0;
  let t16;
  $[17] !== t4 || $[18] !== rootTheme.scheme || $[19] !== tone || $[20] !== restProps || $[21] !== t6 || $[22] !== t7 || $[23] !== t8 || $[24] !== t9 || $[25] !== t10 || $[26] !== checkered || $[27] !== focusRing || $[28] !== muted || $[29] !== t11 || $[30] !== t12 || $[31] !== t13 || $[32] !== t14 || $[33] !== t15 || $[34] !== as || $[35] !== ref || $[36] !== selected ? (t16 = /* @__PURE__ */ jsx(Root$s, { "data-as": t4, "data-scheme": t5, "data-ui": "Card", "data-tone": tone, ...restProps, $border: t6, $borderTop: t7, $borderRight: t8, $borderBottom: t9, $borderLeft: t10, $checkered: checkered, $focusRing: focusRing, $muted: muted, $radius: t11, $shadow: t12, $tone: tone, "data-checkered": t13, "data-pressed": t14, "data-selected": t15, forwardedAs: as, ref, selected }), $[17] = t4, $[18] = rootTheme.scheme, $[19] = tone, $[20] = restProps, $[21] = t6, $[22] = t7, $[23] = t8, $[24] = t9, $[25] = t10, $[26] = checkered, $[27] = focusRing, $[28] = muted, $[29] = t11, $[30] = t12, $[31] = t13, $[32] = t14, $[33] = t15, $[34] = as, $[35] = ref, $[36] = selected, $[37] = t16) : t16 = $[37];
  let t17;
  return $[38] !== scheme || $[39] !== tone || $[40] !== t16 ? (t17 = /* @__PURE__ */ jsx(ThemeColorProvider, { scheme, tone, children: t16 }), $[38] = scheme, $[39] = tone, $[40] = t16, $[41] = t17) : t17 = $[41], t17;
});
Card.displayName = "ForwardRef(Card)";
function checkboxBaseStyles() {
  return css`
    position: relative;
    display: inline-block;
  `;
}
function inputElementStyles(props) {
  const {
    color,
    input,
    radius
  } = getTheme_v2(props.theme), {
    focusRing
  } = input.checkbox;
  return css`
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    opacity: 0;
    z-index: 1;
    padding: 0;
    margin: 0;

    & + span {
      position: relative;
      display: block;
      height: ${rem(input.checkbox.size)};
      width: ${rem(input.checkbox.size)};
      box-sizing: border-box;
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
      border-radius: ${rem(radius[2])};
      line-height: 1;
      background-color: ${color.input.default.enabled.bg};

      & > svg {
        display: block;
        position: absolute;
        opacity: 0;
        height: 100%;
        width: 100%;

        & > path {
          vector-effect: non-scaling-stroke;
          stroke-width: 1.5px !important;
        }
      }
    }

    &:checked + span {
      background: ${color.input.default.enabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.fg,
    width: input.border.width
  })};
      color: ${color.input.default.enabled.bg};
    }

    /* focus */
    &:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    focusRing
  })};
    }

    /* focus when checked - uses a different offset */
    &:not(:disabled):focus:focus-visible&:checked + span {
      box-shadow: ${focusRingStyle({
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &[data-error] + span {
      background-color: ${color.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  })};
      color: ${color.input.default.disabled.fg};
    }
    &[data-error]&:checked + span {
      background-color: ${color.input.invalid.enabled.muted.bg};
      color: ${color.input.default.enabled.bg};
    }
    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.invalid.readOnly.muted.bg
    },
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &:disabled + span {
      background-color: ${color.input.default.disabled.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.disabled.border
  })};
      color: ${color.input.default.disabled.fg};
    }
    &:disabled&:checked + span {
      background-color: ${color.input.default.disabled.muted.bg};
    }

    &[data-read-only] + span {
      background-color: ${color.input.default.readOnly.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.readOnly.border
  })};
      color: ${color.input.default.readOnly.fg};
    }

    &[data-read-only]&:checked + span {
      background-color: ${color.input.default.readOnly.muted.bg};
    }

    &:checked + span > svg:first-child {
      opacity: 1;
    }
    &:indeterminate + span > svg:last-child {
      opacity: 1;
    }
  `;
}
const Root$r = styled.div(checkboxBaseStyles), Input$5 = styled.input(inputElementStyles), Checkbox = forwardRef(function(props, forwardedRef) {
  const $ = c(25);
  let indeterminate, customValidity, disabled, readOnly, restProps, checked, className, style;
  $[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props, $[0] = props, $[1] = indeterminate, $[2] = customValidity, $[3] = disabled, $[4] = readOnly, $[5] = restProps, $[6] = checked, $[7] = className, $[8] = style) : (indeterminate = $[1], customValidity = $[2], disabled = $[3], readOnly = $[4], restProps = $[5], checked = $[6], className = $[7], style = $[8]);
  const ref = useRef(null);
  let t0;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $[9] = t0) : t0 = $[9], useImperativeHandle(forwardedRef, t0);
  let t1, t2;
  $[10] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, t2 = [indeterminate], $[10] = indeterminate, $[11] = t1, $[12] = t2) : (t1 = $[11], t2 = $[12]), useEffect(t1, t2), useCustomValidity(ref, customValidity);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = customValidity ? "" : void 0, t5 = disabled || readOnly;
  let t6;
  $[13] !== t3 || $[14] !== t4 || $[15] !== restProps || $[16] !== checked || $[17] !== t5 || $[18] !== readOnly ? (t6 = /* @__PURE__ */ jsx(Input$5, { "data-read-only": t3, "data-error": t4, ...restProps, checked, disabled: t5, type: "checkbox", readOnly, ref }), $[13] = t3, $[14] = t4, $[15] = restProps, $[16] = checked, $[17] = t5, $[18] = readOnly, $[19] = t6) : t6 = $[19];
  let t7;
  $[20] === Symbol.for("react.memo_cache_sentinel") ? (t7 = /* @__PURE__ */ jsxs("span", { children: [
    /* @__PURE__ */ jsx(CheckmarkIcon, {}),
    /* @__PURE__ */ jsx(RemoveIcon, {})
  ] }), $[20] = t7) : t7 = $[20];
  let t8;
  return $[21] !== className || $[22] !== style || $[23] !== t6 ? (t8 = /* @__PURE__ */ jsxs(Root$r, { className, "data-ui": "Checkbox", style, children: [
    t6,
    t7
  ] }), $[21] = className, $[22] = style, $[23] = t6, $[24] = t8) : t8 = $[24], t8;
});
Checkbox.displayName = "ForwardRef(Checkbox)";
function codeSyntaxHighlightingStyle({
  theme
}) {
  const {
    color: {
      syntax: color
    }
  } = getTheme_v2(theme);
  return {
    "&.atrule": {
      color: color.atrule
    },
    "&.attr-name": {
      color: color.attrName
    },
    "&.attr-value": {
      color: color.attrValue
    },
    "&.attribute": {
      color: color.attribute
    },
    "&.boolean": {
      color: color.boolean
    },
    "&.builtin": {
      color: color.builtin
    },
    "&.cdata": {
      color: color.cdata
    },
    "&.char": {
      color: color.char
    },
    "&.class": {
      color: color.class
    },
    "&.class-name": {
      color: color.className
    },
    "&.comment": {
      color: color.comment
    },
    "&.constant": {
      color: color.constant
    },
    "&.deleted": {
      color: color.deleted
    },
    "&.doctype": {
      color: color.doctype
    },
    "&.entity": {
      color: color.entity
    },
    "&.function": {
      color: color.function
    },
    "&.hexcode": {
      color: color.hexcode
    },
    "&.id": {
      color: color.id
    },
    "&.important": {
      color: color.important
    },
    "&.inserted": {
      color: color.inserted
    },
    "&.keyword": {
      color: color.keyword
    },
    "&.number": {
      color: color.number
    },
    "&.operator": {
      color: color.operator
    },
    "&.prolog": {
      color: color.prolog
    },
    "&.property": {
      color: color.property
    },
    "&.pseudo-class": {
      color: color.pseudoClass
    },
    "&.pseudo-element": {
      color: color.pseudoElement
    },
    "&.punctuation": {
      color: color.punctuation
    },
    "&.regex": {
      color: color.regex
    },
    "&.selector": {
      color: color.selector
    },
    "&.string": {
      color: color.string
    },
    "&.symbol": {
      color: color.symbol
    },
    "&.tag": {
      color: color.tag
    },
    "&.unit": {
      color: color.unit
    },
    "&.url": {
      color: color.url
    },
    "&.variable": {
      color: color.variable
    }
  };
}
function codeBaseStyle() {
  return css`
    color: var(--card-code-fg-color);

    & code {
      font-family: inherit;

      &.refractor .token {
        ${codeSyntaxHighlightingStyle}
      }
    }

    & a {
      color: inherit;
      text-decoration: underline;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$q = styled.pre(codeBaseStyle, responsiveCodeFontStyle), Code = forwardRef(function(props, ref) {
  const $ = c(23);
  let t0, languageProp, children, restProps, weight;
  $[0] !== props ? ({
    children,
    language: languageProp,
    size: t0,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = languageProp, $[3] = children, $[4] = restProps, $[5] = weight) : (t0 = $[1], languageProp = $[2], children = $[3], restProps = $[4], weight = $[5]);
  const size2 = t0 === void 0 ? 2 : t0, language = typeof languageProp == "string" ? languageProp : void 0;
  let t1;
  $[6] !== language ? (t1 = language ? Refractor.hasLanguage(language) : !1, $[6] = language, $[7] = t1) : t1 = $[7];
  const registered = t1, t2 = useArrayProp(size2);
  let t3;
  $[8] !== language || $[9] !== registered || $[10] !== children ? (t3 = !(language && registered) && /* @__PURE__ */ jsx("code", { children }), $[8] = language, $[9] = registered, $[10] = children, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== language || $[13] !== registered || $[14] !== children ? (t4 = language && registered && /* @__PURE__ */ jsx(Refractor, { inline: !0, language, value: String(children) }), $[12] = language, $[13] = registered, $[14] = children, $[15] = t4) : t4 = $[15];
  let t5;
  return $[16] !== restProps || $[17] !== t2 || $[18] !== weight || $[19] !== ref || $[20] !== t3 || $[21] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Root$q, { "data-ui": "Code", ...restProps, $size: t2, $weight: weight, ref, children: [
    t3,
    t4
  ] }), $[16] = restProps, $[17] = t2, $[18] = weight, $[19] = ref, $[20] = t3, $[21] = t4, $[22] = t5) : t5 = $[22], t5;
});
Code.displayName = "ForwardRef(Code)";
const BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    container,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$p = styled(Box)(containerBaseStyle, responsiveContainerWidthStyle), Container = forwardRef(function(props, ref) {
  const $ = c(9);
  let t0, restProps, as;
  $[0] !== props ? ({
    as,
    width: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps, $[3] = as) : (t0 = $[1], restProps = $[2], as = $[3]);
  const t1 = useArrayProp(t0 === void 0 ? 2 : t0);
  let t2;
  return $[4] !== restProps || $[5] !== t1 || $[6] !== as || $[7] !== ref ? (t2 = /* @__PURE__ */ jsx(Root$p, { "data-ui": "Container", ...restProps, $width: t1, forwardedAs: as, ref }), $[4] = restProps, $[5] = t1, $[6] = as, $[7] = ref, $[8] = t2) : t2 = $[8], t2;
});
Container.displayName = "ForwardRef(Container)";
const Root$o = styled(Box)(responsiveGridStyle), Grid = forwardRef(function(props, ref) {
  const $ = c(26);
  let as, autoRows, autoCols, autoFlow, columns, gap, gapX, gapY, rows, restProps, children;
  $[0] !== props ? ({
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props, $[0] = props, $[1] = as, $[2] = autoRows, $[3] = autoCols, $[4] = autoFlow, $[5] = columns, $[6] = gap, $[7] = gapX, $[8] = gapY, $[9] = rows, $[10] = restProps, $[11] = children) : (as = $[1], autoRows = $[2], autoCols = $[3], autoFlow = $[4], columns = $[5], gap = $[6], gapX = $[7], gapY = $[8], rows = $[9], restProps = $[10], children = $[11]);
  const t0 = typeof as == "string" ? as : void 0, t1 = useArrayProp(autoRows), t2 = useArrayProp(autoCols), t3 = useArrayProp(autoFlow), t4 = useArrayProp(columns), t5 = useArrayProp(gap), t6 = useArrayProp(gapX), t7 = useArrayProp(gapY), t8 = useArrayProp(rows);
  let t9;
  return $[12] !== t0 || $[13] !== restProps || $[14] !== t1 || $[15] !== t2 || $[16] !== t3 || $[17] !== t4 || $[18] !== t5 || $[19] !== t6 || $[20] !== t7 || $[21] !== t8 || $[22] !== as || $[23] !== ref || $[24] !== children ? (t9 = /* @__PURE__ */ jsx(Root$o, { "data-as": t0, "data-ui": "Grid", ...restProps, $autoRows: t1, $autoCols: t2, $autoFlow: t3, $columns: t4, $gap: t5, $gapX: t6, $gapY: t7, $rows: t8, forwardedAs: as, ref, children }), $[12] = t0, $[13] = restProps, $[14] = t1, $[15] = t2, $[16] = t3, $[17] = t4, $[18] = t5, $[19] = t6, $[20] = t7, $[21] = t8, $[22] = as, $[23] = ref, $[24] = children, $[25] = t9) : t9 = $[25], t9;
});
Grid.displayName = "ForwardRef(Grid)";
function headingBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return css`
    ${$accent && css`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && css`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.heading.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$n = styled.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont), SpanWithTextOverflow = styled.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Heading = forwardRef(function(props, ref) {
  const $ = c(22);
  let t0, t1, t2, childrenProp, textOverflow, align, restProps, weight;
  $[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t2,
    textOverflow,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = childrenProp, $[5] = textOverflow, $[6] = align, $[7] = restProps, $[8] = weight) : (t0 = $[1], t1 = $[2], t2 = $[3], childrenProp = $[4], textOverflow = $[5], align = $[6], restProps = $[7], weight = $[8]);
  const accent = t0 === void 0 ? !1 : t0, muted = t1 === void 0 ? !1 : t1, size2 = t2 === void 0 ? 2 : t2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $[9] !== children ? (t32 = /* @__PURE__ */ jsx(SpanWithTextOverflow, { children }), $[9] = children, $[10] = t32) : t32 = $[10], children = t32;
  }
  const t3 = useArrayProp(align), t4 = useArrayProp(size2);
  let t5;
  $[11] !== children ? (t5 = /* @__PURE__ */ jsx("span", { children }), $[11] = children, $[12] = t5) : t5 = $[12];
  let t6;
  return $[13] !== restProps || $[14] !== accent || $[15] !== t3 || $[16] !== muted || $[17] !== t4 || $[18] !== weight || $[19] !== ref || $[20] !== t5 ? (t6 = /* @__PURE__ */ jsx(Root$n, { "data-ui": "Heading", ...restProps, $accent: accent, $align: t3, $muted: muted, $size: t4, $weight: weight, ref, children: t5 }), $[13] = restProps, $[14] = accent, $[15] = t3, $[16] = muted, $[17] = t4, $[18] = weight, $[19] = ref, $[20] = t5, $[21] = t6) : t6 = $[21], t6;
});
Heading.displayName = "ForwardRef(Heading)";
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => {
    const _space = rem(spaceIndex === 0.5 ? space[1] / 2 : space[spaceIndex]);
    return {
      margin: `-${_space} 0 0 -${_space}`,
      "& > div": {
        padding: `${_space} 0 0 ${_space}`
      }
    };
  });
}
const Root$m = styled(Box)(inlineBaseStyle, inlineSpaceStyle), Inline = forwardRef(function(props, ref) {
  const $ = c(13);
  let childrenProp, space, restProps, as;
  $[0] !== props ? ({
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props, $[0] = props, $[1] = childrenProp, $[2] = space, $[3] = restProps, $[4] = as) : (childrenProp = $[1], space = $[2], restProps = $[3], as = $[4]);
  let t0, t1;
  if ($[5] !== childrenProp) {
    let t22;
    $[7] === Symbol.for("react.memo_cache_sentinel") ? (t22 = (child) => child && /* @__PURE__ */ jsx("div", { children: child }), $[7] = t22) : t22 = $[7], t1 = Children.map(childrenProp, t22), $[5] = childrenProp, $[6] = t1;
  } else
    t1 = $[6];
  t0 = t1;
  const children = t0, t2 = useArrayProp(space);
  let t3;
  return $[8] !== restProps || $[9] !== t2 || $[10] !== as || $[11] !== children ? (t3 = /* @__PURE__ */ jsx(Root$m, { "data-ui": "Inline", ...restProps, $space: t2, forwardedAs: as, ref, children }), $[8] = restProps, $[9] = t2, $[10] = as, $[11] = children, $[12] = t3) : t3 = $[12], t3;
});
Inline.displayName = "ForwardRef(Inline)";
function kbdStyle() {
  return css`
    --card-bg-color: var(--card-kbd-bg-color);
    --card-border-color: var(--card-kbd-border-color);
    --card-fg-color: var(--card-kbd-fg-color);

    box-shadow: inset 0 0 0 1px var(--card-border-color);
    background: var(--card-bg-color);
    font: inherit;

    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
const Root$l = styled.kbd(responsiveRadiusStyle, kbdStyle), KBD = forwardRef(function(props, ref) {
  const $ = c(17);
  let t0, t1, t2, children, restProps;
  $[0] !== props ? ({
    children,
    fontSize: t0,
    padding: t1,
    radius: t2,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = children, $[5] = restProps) : (t0 = $[1], t1 = $[2], t2 = $[3], children = $[4], restProps = $[5]);
  const fontSize2 = t0 === void 0 ? 0 : t0, padding = t1 === void 0 ? 1 : t1, t3 = useArrayProp(t2 === void 0 ? 2 : t2);
  let t4;
  $[6] !== fontSize2 || $[7] !== children ? (t4 = /* @__PURE__ */ jsx(Text, { as: "span", size: fontSize2, weight: "semibold", children }), $[6] = fontSize2, $[7] = children, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== padding || $[10] !== t4 ? (t5 = /* @__PURE__ */ jsx(Box, { as: "span", padding, children: t4 }), $[9] = padding, $[10] = t4, $[11] = t5) : t5 = $[11];
  let t6;
  return $[12] !== restProps || $[13] !== t3 || $[14] !== ref || $[15] !== t5 ? (t6 = /* @__PURE__ */ jsx(Root$l, { "data-ui": "KBD", ...restProps, $radius: t3, ref, children: t5 }), $[12] = restProps, $[13] = t3, $[14] = ref, $[15] = t5, $[16] = t6) : t6 = $[16], t6;
});
KBD.displayName = "ForwardRef(KBD)";
const origin = {
  name: "@sanity/ui/origin",
  fn({
    middlewareData,
    placement,
    rects
  }) {
    const [side] = placement.split("-"), floatingWidth = rects.floating.width, floatingHeight = rects.floating.height, shiftX = middlewareData.shift?.x || 0, shiftY = middlewareData.shift?.y || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0)
      return {};
    const isVerticalPlacement = ["bottom", "top"].includes(side), {
      originX,
      originY
    } = isVerticalPlacement ? {
      originX: clamp(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: {
        originX,
        originY
      }
    };
  }
};
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x, height = targetPoint.y - movingPoint.y, distance = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length, cmds = [];
  for (let i = 0; i < len; i += 1) {
    const point = points[i], prevPoint = points[i - 1], nextPoint = points[i + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius), curveEnd = moveTowardsLength(point, nextPoint, point.radius), startControl = moveTowardsFractional(curveStart, point, 0.5), endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      }), cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else
      cmds.push({
        type: "point",
        ...point
      });
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n, idx) => n.type === "point" ? `${idx === 0 ? "M" : "L"} ${n.x} ${n.y}` : n.type === "curve" ? `C ${n.startControl.x} ${n.startControl.y} ${n.endControl.x} ${n.endControl.y} ${n.curveEnd.x} ${n.curveEnd.y}` : "").join(" ");
}
const Root$k = styled.div(({
  $w: w
}) => css`
    position: absolute;
    width: ${w}px;
    height: ${w}px;

    :empty + & {
      display: none;
    }

    & > svg {
      display: block;
      line-height: 0;
      transform-origin: ${w / 2}px ${w / 2}px;
    }

    [data-placement^='top'] > & {
      bottom: -${w}px;

      & > svg {
        transform: rotate(0);
      }
    }

    [data-placement^='right'] > & {
      left: -${w}px;

      & > svg {
        transform: rotate(90deg);
      }
    }

    [data-placement^='left'] > & {
      right: -${w}px;

      & > svg {
        transform: rotate(-90deg);
      }
    }

    [data-placement^='bottom'] > & {
      top: -${w}px;

      & > svg {
        transform: rotate(180deg);
      }
    }
  `), StrokePath = styled.path`
  stroke: var(--card-shadow-outline-color);
`, ShapePath = styled.path`
  fill: var(--card-bg-color);
`, Arrow = forwardRef(function(props, ref) {
  const $ = c(24);
  let t0, w, h, restProps;
  $[0] !== props ? ({
    width: w,
    height: h,
    radius: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = w, $[3] = h, $[4] = restProps) : (t0 = $[1], w = $[2], h = $[3], restProps = $[4]);
  const radius = t0 === void 0 ? 0 : t0, {
    card
  } = useTheme_v2(), strokeWidth = card.shadow.outline, center = w / 2, points = [{
    x: 0,
    y: 0
  }, {
    x: radius,
    y: 0,
    radius
  }, {
    x: center,
    y: h - 1,
    radius
  }, {
    x: w - radius,
    y: 0,
    radius
  }, {
    x: w,
    y: 0
  }], cmds = getRoundedCommands(points), path = compileCommands(cmds), strokePath = `${path}`, fillPath = `${path} M ${w} -1 M 0 -1 Z`, t1 = `0 0 ${w} ${w}`;
  let t2;
  $[5] !== strokeWidth || $[6] !== w ? (t2 = /* @__PURE__ */ jsx("mask", { id: "stroke-mask", children: /* @__PURE__ */ jsx("rect", { x: 0, y: strokeWidth, width: w, height: w, fill: "white" }) }), $[5] = strokeWidth, $[6] = w, $[7] = t2) : t2 = $[7];
  const t3 = strokeWidth * 2;
  let t4;
  $[8] !== strokePath || $[9] !== t3 ? (t4 = /* @__PURE__ */ jsx(StrokePath, { d: strokePath, mask: "url(#stroke-mask)", strokeWidth: t3 }), $[8] = strokePath, $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== fillPath ? (t5 = /* @__PURE__ */ jsx(ShapePath, { d: fillPath }), $[11] = fillPath, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== w || $[14] !== t1 || $[15] !== t2 || $[16] !== t4 || $[17] !== t5 ? (t6 = /* @__PURE__ */ jsxs("svg", { width: w, height: w, viewBox: t1, children: [
    t2,
    t4,
    t5
  ] }), $[13] = w, $[14] = t1, $[15] = t2, $[16] = t4, $[17] = t5, $[18] = t6) : t6 = $[18];
  let t7;
  return $[19] !== restProps || $[20] !== w || $[21] !== ref || $[22] !== t6 ? (t7 = /* @__PURE__ */ jsx(Root$k, { ...restProps, $w: w, ref, children: t6 }), $[19] = restProps, $[20] = w, $[21] = ref, $[22] = t6, $[23] = t7) : t7 = $[23], t7;
});
Arrow.displayName = "ForwardRef(Arrow)";
const BoundaryElementContext = createGlobalScopedContext("@sanity/ui/context/boundaryElement", null);
function BoundaryElementProvider(props) {
  const $ = c(5), {
    children,
    element
  } = props;
  let t0, t1;
  $[0] !== element ? (t1 = {
    version: 0,
    element
  }, $[0] = element, $[1] = t1) : t1 = $[1], t0 = t1;
  const value = t0;
  let t2;
  return $[2] !== value || $[3] !== children ? (t2 = /* @__PURE__ */ jsx(BoundaryElementContext.Provider, { value, children }), $[2] = value, $[3] = children, $[4] = t2) : t2 = $[4], t2;
}
BoundaryElementProvider.displayName = "BoundaryElementProvider";
function isRecord(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0))
    throw new Error("useBoundaryElement(): the context value is not compatible");
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper({
  children,
  condition,
  wrapper
}) {
  return condition ? wrapper(children) : children;
}
ConditionalWrapper.displayName = "ConditionalWrapper";
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] > width && ret.push(i);
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] <= width && ret.push(i);
  return ret;
}
const ElementQuery = forwardRef(function(props, forwardedRef) {
  const theme = useTheme_v2(), {
    children,
    media = theme.media,
    ...restProps
  } = props, ref = useRef(null), [element, setElement] = useState(null), elementSize = useElementSize(element), width = useMemo(() => elementSize?.border.width ?? window.innerWidth, [elementSize]), max = useMemo(() => findMaxBreakpoints(media, width), [media, width]), min = useMemo(() => findMinBreakpoints(media, width), [media, width]);
  useImperativeHandle(forwardedRef, () => ref.current);
  const setRef = useCallback((el) => {
    ref.current = el, setElement(el);
  }, []);
  return /* @__PURE__ */ jsx("div", { "data-ui": "ElementQuery", ...restProps, "data-eq-max": max.length ? max.join(" ") : void 0, "data-eq-min": min.length ? min.join(" ") : void 0, ref: setRef, children });
});
ElementQuery.displayName = "ForwardRef(ElementQuery)";
class ErrorBoundary extends Component {
  state = {
    error: null
  };
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof error?.message == "string" ? error.message : "Error";
      return /* @__PURE__ */ jsx(Code, { children: message });
    }
    return this.props.children;
  }
}
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0)
    throw new Error("the context value is not compatible");
  if (!contextValue)
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  if (contextValue.version === 0)
    return contextValue;
  throw new Error("could not get layer context");
}
const LayerContext = createGlobalScopedContext("@sanity/ui/context/layer", null);
function useLayer() {
  const $ = c(2), value = useContext(LayerContext);
  if (!value)
    throw new Error("useLayer(): missing context value");
  try {
    let t1;
    return $[0] !== value ? (t1 = getLayerContext(value), $[0] = value, $[1] = t1) : t1 = $[1], t1;
  } catch (t0) {
    const err = t0;
    throw err instanceof Error ? new Error(`useLayer(): ${err.message}`) : new Error(`useLayer(): ${err}`);
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    innerDispose && innerDispose(), outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? !0 : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : !1;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return !1;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return !0;
  }
  return !1;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return !0;
  }
  return !1;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return !1;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props) {
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props, parentContextValue = useContext(LayerContext), parent = parentContextValue && getLayerContext(parentContextValue), parentRegisterChild = parent?.registerChild, level = (parent?.level ?? 0) + 1, zOffset = useArrayProp(zOffsetProp), maxMediaIndex = zOffset.length - 1, mediaIndex = Math.min(useMediaIndex(), maxMediaIndex), zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex], [, setChildLayers] = useState({}), [size2, setSize] = useState(0), isTopLayer = size2 === 0, registerChild = useCallback((childLevel) => {
    const parentDispose = parentRegisterChild?.(childLevel);
    return childLevel !== void 0 ? setChildLayers((state) => {
      const prevLen = state[childLevel] ?? 0, nextState = {
        ...state,
        [childLevel]: prevLen + 1
      };
      return setSize(Object.keys(nextState).length), nextState;
    }) : setSize((v) => v + 1), () => {
      childLevel !== void 0 ? setChildLayers((state_0) => {
        const nextState_0 = {
          ...state_0
        };
        return nextState_0[childLevel] === 1 ? (delete nextState_0[childLevel], setSize(Object.keys(nextState_0).length)) : nextState_0[childLevel] -= 1, nextState_0;
      }) : setSize((v_0) => v_0 - 1), parentDispose?.();
    };
  }, [parentRegisterChild]);
  useEffect(() => parentRegisterChild?.(level), [level, parentRegisterChild]);
  const value = useMemo(() => ({
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size: size2,
    zIndex
  }), [isTopLayer, level, registerChild, size2, zIndex]);
  return /* @__PURE__ */ jsx(LayerContext.Provider, { value, children });
}
LayerProvider.displayName = "LayerProvider";
const Root$j = styled.div({
  position: "relative"
}), LayerChildren = forwardRef(function(props, forwardedRef) {
  const $ = c(22);
  let t0, onActivate, onFocus, restProps, children;
  $[0] !== props ? ({
    children,
    onActivate,
    onFocus,
    style: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = onActivate, $[3] = onFocus, $[4] = restProps, $[5] = children) : (t0 = $[1], onActivate = $[2], onFocus = $[3], restProps = $[4], children = $[5]);
  const style = t0 === void 0 ? EMPTY_RECORD : t0, {
    zIndex,
    isTopLayer
  } = useLayer(), lastFocusedRef = useRef(null), ref = useRef(null), isTopLayerRef = useRef(isTopLayer);
  let t1;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => ref.current, $[6] = t1) : t1 = $[6], useImperativeHandle(forwardedRef, t1);
  let t2, t3;
  $[7] !== isTopLayer || $[8] !== onActivate ? (t2 = () => {
    isTopLayerRef.current !== isTopLayer && isTopLayer && onActivate?.({
      activeElement: lastFocusedRef.current
    }), isTopLayerRef.current = isTopLayer;
  }, t3 = [isTopLayer, onActivate], $[7] = isTopLayer, $[8] = onActivate, $[9] = t2, $[10] = t3) : (t2 = $[9], t3 = $[10]), useEffect(t2, t3);
  let t4;
  $[11] !== onFocus || $[12] !== isTopLayer ? (t4 = (event) => {
    onFocus?.(event);
    const rootElement = ref.current, target = document.activeElement;
    !isTopLayer || !rootElement || !target || isHTMLElement(target) && containsOrEqualsElement(rootElement, target) && (lastFocusedRef.current = target);
  }, $[11] = onFocus, $[12] = isTopLayer, $[13] = t4) : t4 = $[13];
  const handleFocus = t4;
  let t5;
  $[14] !== style || $[15] !== zIndex ? (t5 = {
    ...style,
    zIndex
  }, $[14] = style, $[15] = zIndex, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== restProps || $[18] !== handleFocus || $[19] !== t5 || $[20] !== children ? (t6 = /* @__PURE__ */ jsx(Root$j, { ...restProps, "data-ui": "Layer", onFocus: handleFocus, ref, style: t5, children }), $[17] = restProps, $[18] = handleFocus, $[19] = t5, $[20] = children, $[21] = t6) : t6 = $[21], t6;
}), Layer = forwardRef(function(props, ref) {
  const $ = c(11);
  let t0, restProps, children;
  $[0] !== props ? ({
    children,
    zOffset: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps, $[3] = children) : (t0 = $[1], restProps = $[2], children = $[3]);
  const zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $[4] !== restProps || $[5] !== ref || $[6] !== children ? (t1 = /* @__PURE__ */ jsx(LayerChildren, { ...restProps, ref, children }), $[4] = restProps, $[5] = ref, $[6] = children, $[7] = t1) : t1 = $[7];
  let t2;
  return $[8] !== zOffset || $[9] !== t1 ? (t2 = /* @__PURE__ */ jsx(LayerProvider, { zOffset, children: t1 }), $[8] = zOffset, $[9] = t1, $[10] = t2) : t2 = $[10], t2;
});
Layer.displayName = "ForwardRef(Layer)";
const key = "@sanity/ui/context/portal", elementKey = Symbol.for(`${key}/element`);
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    return typeof document > "u" ? null : (globalScope[elementKey] || (globalScope[elementKey] = document.createElement("div"), globalScope[elementKey].setAttribute("data-portal", ""), document.body.appendChild(globalScope[elementKey])), globalScope[elementKey]);
  }
}, PortalContext = createGlobalScopedContext(key, defaultContextValue);
function usePortal() {
  const value = useContext(PortalContext);
  if (!value)
    throw new Error("usePortal(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("usePortal(): the context value is not compatible");
  return value;
}
function Portal(props) {
  const $ = c(3), {
    children,
    __unstable_name: name
  } = props, portal = usePortal(), portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || portal.elements?.default;
  if (!portalElement)
    return null;
  let t0;
  return $[0] !== children || $[1] !== portalElement ? (t0 = createPortal(children, portalElement), $[0] = children, $[1] = portalElement, $[2] = t0) : t0 = $[2], t0;
}
Portal.displayName = "Portal";
function PortalProvider(props) {
  const $ = c(7), {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props, elements = useUnique(elementsProp), fallbackElement = useSyncExternalStore(emptySubscribe, _temp$3, _temp2$1);
  let t0;
  const t1 = boundaryElement || null, t2 = element || fallbackElement;
  let t3;
  $[0] !== t1 || $[1] !== t2 || $[2] !== elements ? (t3 = {
    version: 0,
    boundaryElement: t1,
    element: t2,
    elements
  }, $[0] = t1, $[1] = t2, $[2] = elements, $[3] = t3) : t3 = $[3], t0 = t3;
  const value = t0;
  let t4;
  return $[4] !== value || $[5] !== children ? (t4 = /* @__PURE__ */ jsx(PortalContext.Provider, { value, children }), $[4] = value, $[5] = children, $[6] = t4) : t4 = $[6], t4;
}
function _temp2$1() {
  return null;
}
function _temp$3() {
  return document.body;
}
PortalProvider.displayName = "PortalProvider";
const emptySubscribe = () => () => {
};
function useUnique(value) {
  const valueRef = useRef(value);
  return _isEqual(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB)
    return objA === objB;
  const keysA = Object.keys(objA), keysB = Object.keys(objB);
  return keysA.length !== keysB.length ? !1 : keysA.every((key2) => objA[key2] === objB[key2]);
}
const Root$i = styled.div`
  display: block;
  width: 0;
  height: 0;
  position: absolute;
  overflow: hidden;
  overflow: clip;
`, SrOnly = forwardRef(function(props, ref) {
  const $ = c(4), {
    as,
    children
  } = props;
  let t0;
  return $[0] !== as || $[1] !== ref || $[2] !== children ? (t0 = /* @__PURE__ */ jsx(Root$i, { "aria-hidden": !0, as, "data-ui": "SrOnly", ref, children }), $[0] = as, $[1] = ref, $[2] = children, $[3] = t0) : t0 = $[3], t0;
});
SrOnly.displayName = "ForwardRef(SrOnly)";
const Root$h = styled.div`
  position: relative;
`, ItemWrapper = styled.div`
  position: absolute;
  left: 0;
  right: 0;
`, VirtualList = forwardRef(function(props, forwardedRef) {
  const $ = c(56);
  let t0, t1, t2, renderItem, onChange, getItemKey, restProps;
  $[0] !== props ? ({
    as: t0,
    gap: t1,
    getItemKey,
    items: t2,
    onChange,
    renderItem,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = renderItem, $[5] = onChange, $[6] = getItemKey, $[7] = restProps) : (t0 = $[1], t1 = $[2], t2 = $[3], renderItem = $[4], onChange = $[5], getItemKey = $[6], restProps = $[7]);
  const as = t0 === void 0 ? "div" : t0, gap = t1 === void 0 ? 0 : t1;
  let t3;
  $[8] !== t2 ? (t3 = t2 === void 0 ? [] : t2, $[8] = t2, $[9] = t3) : t3 = $[9];
  const items = t3, {
    space
  } = useTheme_v2(), ref = useRef(null), wrapperRef = useRef(null), [scrollTop, setScrollTop] = useState(0), [scrollHeight, setScrollHeight] = useState(0), [itemHeight, setItemHeight] = useState(-1);
  let t4;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $[10] = t4) : t4 = $[10], useImperativeHandle(forwardedRef, t4);
  let t5;
  $[11] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    firstElement instanceof HTMLElement && setItemHeight(firstElement.offsetHeight);
  }, $[11] = t5) : t5 = $[11];
  let t6;
  $[12] !== renderItem ? (t6 = [renderItem], $[12] = renderItem, $[13] = t6) : t6 = $[13], useEffect(t5, t6);
  let t7, t8;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => {
    if (!ref.current)
      return;
    let _scrollEl = ref.current.parentNode;
    for (; _scrollEl && !_isScrollable(_scrollEl); )
      _scrollEl = _scrollEl.parentNode;
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll, {
        passive: !0
      });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      return ro.observe(scrollEl), handleScroll(), () => {
        scrollEl.removeEventListener("scroll", handleScroll), ro.unobserve(scrollEl), ro.disconnect();
      };
    }
    const handleScroll_0 = () => {
      setScrollTop(window.scrollY);
    }, handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    return window.addEventListener("scroll", handleScroll_0, {
      passive: !0
    }), window.addEventListener("resize", handleResize), setScrollHeight(window.innerHeight), handleScroll_0(), () => {
      window.removeEventListener("scroll", handleScroll_0), window.removeEventListener("resize", handleResize);
    };
  }, t8 = [], $[14] = t7, $[15] = t8) : (t7 = $[14], t8 = $[15]), useEffect(t7, t8);
  const len = items.length, height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0, fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0, toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  let t9, t10;
  $[16] !== onChange || $[17] !== fromIndex || $[18] !== space || $[19] !== gap || $[20] !== itemHeight || $[21] !== scrollHeight || $[22] !== scrollTop || $[23] !== toIndex ? (t9 = () => {
    onChange && onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, t10 = [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex], $[16] = onChange, $[17] = fromIndex, $[18] = space, $[19] = gap, $[20] = itemHeight, $[21] = scrollHeight, $[22] = scrollTop, $[23] = toIndex, $[24] = t9, $[25] = t10) : (t9 = $[24], t10 = $[25]), useEffect(t9, t10);
  let t11;
  bb0: {
    if (!renderItem || items.length === 0) {
      t11 = null;
      break bb0;
    }
    if (itemHeight === -1) {
      const t123 = items[0];
      let t132;
      $[26] !== renderItem || $[27] !== t123 ? (t132 = renderItem(t123), $[26] = renderItem, $[27] = t123, $[28] = t132) : t132 = $[28];
      let t142;
      $[29] !== t132 ? (t142 = [/* @__PURE__ */ jsx(ItemWrapper, { children: t132 }, 0)], $[29] = t132, $[30] = t142) : t142 = $[30], t11 = t142;
      break bb0;
    }
    let t122;
    if ($[31] !== items || $[32] !== fromIndex || $[33] !== toIndex || $[34] !== renderItem || $[35] !== getItemKey || $[36] !== itemHeight || $[37] !== space || $[38] !== gap) {
      let t132;
      $[40] !== fromIndex || $[41] !== renderItem || $[42] !== getItemKey || $[43] !== itemHeight || $[44] !== space || $[45] !== gap ? (t132 = (item, _itemIndex) => {
        const itemIndex = fromIndex + _itemIndex, node = renderItem(item), key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
        return /* @__PURE__ */ jsx(ItemWrapper, { style: {
          top: itemIndex * (itemHeight + space[gap])
        }, children: node }, key2);
      }, $[40] = fromIndex, $[41] = renderItem, $[42] = getItemKey, $[43] = itemHeight, $[44] = space, $[45] = gap, $[46] = t132) : t132 = $[46], t122 = items.slice(fromIndex, toIndex).map(t132), $[31] = items, $[32] = fromIndex, $[33] = toIndex, $[34] = renderItem, $[35] = getItemKey, $[36] = itemHeight, $[37] = space, $[38] = gap, $[39] = t122;
    } else
      t122 = $[39];
    t11 = t122;
  }
  const children = t11;
  let t12, t13;
  $[47] !== height ? (t13 = {
    height
  }, $[47] = height, $[48] = t13) : t13 = $[48], t12 = t13;
  const wrapperStyle = t12;
  let t14;
  $[49] !== wrapperStyle || $[50] !== children ? (t14 = /* @__PURE__ */ jsx("div", { ref: wrapperRef, style: wrapperStyle, children }), $[49] = wrapperStyle, $[50] = children, $[51] = t14) : t14 = $[51];
  let t15;
  return $[52] !== as || $[53] !== restProps || $[54] !== t14 ? (t15 = /* @__PURE__ */ jsx(Root$h, { as, "data-ui": "VirtualList", ...restProps, ref, children: t14 }), $[52] = as, $[53] = restProps, $[54] = t14, $[55] = t15) : t15 = $[55], t15;
});
VirtualList.displayName = "ForwardRef(VirtualList)";
const DEFAULT_POPOVER_DISTANCE = 4, DEFAULT_POPOVER_PADDING = 4, DEFAULT_POPOVER_ARROW_WIDTH = 19, DEFAULT_POPOVER_ARROW_HEIGHT = 8, DEFAULT_POPOVER_ARROW_RADIUS = 2, DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0], DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args, {
        floating,
        reference
      } = rects, overflow = await detectOverflow(args, {
        altBoundary: !0,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = 1 / 0, maxHeight = 1 / 0;
      const floatingW = floating.width, floatingH = floating.height;
      placement.includes("top") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.top), placement.includes("right") && (maxWidth = floatingW - overflow.right, maxHeight = floatingH - (overflow.top + overflow.bottom)), placement.includes("bottom") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.bottom), placement.includes("left") && (maxWidth = floatingW - overflow.left, maxHeight = floatingH - (overflow.top + overflow.bottom)), apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating), targetH = nextDimensions.height, targetW = nextDimensions.width;
      return floatingW !== targetW || floatingH !== targetH ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    container,
    mediaIndex,
    width
  } = params, w = width[mediaIndex], currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth == "number" ? container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (!(currentWidth === void 0 && boundaryWidth === void 0))
    return Math.min(currentWidth ?? 1 / 0, (boundaryWidth || 1 / 0) - DEFAULT_POPOVER_PADDING * 2);
}
const MotionCard$1 = styled(motion(Card))`
  &:not([hidden]) {
    display: flex;
  }
  flex-direction: column;
  width: max-content;
  min-width: min-content;
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, PopoverCard = memo(forwardRef(function(props, ref) {
  const $ = c(60);
  let marginsProp, xProp, yProp, animate, originX, originY, strategy, style, width, arrowX, arrowY, restProps, padding, children, overflow, arrow2, arrowRef, placement, radius, scheme, shadow, tone;
  $[0] !== props ? ({
    __unstable_margins: marginsProp,
    animate,
    arrow: arrow2,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    originX,
    originY,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props, $[0] = props, $[1] = marginsProp, $[2] = xProp, $[3] = yProp, $[4] = animate, $[5] = originX, $[6] = originY, $[7] = strategy, $[8] = style, $[9] = width, $[10] = arrowX, $[11] = arrowY, $[12] = restProps, $[13] = padding, $[14] = children, $[15] = overflow, $[16] = arrow2, $[17] = arrowRef, $[18] = placement, $[19] = radius, $[20] = scheme, $[21] = shadow, $[22] = tone) : (marginsProp = $[1], xProp = $[2], yProp = $[3], animate = $[4], originX = $[5], originY = $[6], strategy = $[7], style = $[8], width = $[9], arrowX = $[10], arrowY = $[11], restProps = $[12], padding = $[13], children = $[14], overflow = $[15], arrow2 = $[16], arrowRef = $[17], placement = $[18], radius = $[19], scheme = $[20], shadow = $[21], tone = $[22]);
  const {
    zIndex
  } = useLayer();
  let t0;
  t0 = marginsProp || DEFAULT_POPOVER_MARGINS;
  const margins = t0, x = (xProp ?? 0) + margins[3], y = (yProp ?? 0) + margins[0];
  let t1;
  const t2 = animate ? "transform" : void 0;
  let t3;
  $[23] !== x || $[24] !== originX || $[25] !== originY || $[26] !== strategy || $[27] !== y || $[28] !== width || $[29] !== zIndex || $[30] !== t2 || $[31] !== style ? (t3 = {
    left: x,
    originX,
    originY,
    position: strategy,
    top: y,
    width,
    zIndex,
    willChange: t2,
    ...style
  }, $[23] = x, $[24] = originX, $[25] = originY, $[26] = strategy, $[27] = y, $[28] = width, $[29] = zIndex, $[30] = t2, $[31] = style, $[32] = t3) : t3 = $[32], t1 = t3;
  const rootStyle2 = t1;
  let t4;
  const t5 = arrowX !== null ? arrowX : void 0, t6 = arrowY !== null ? arrowY : void 0;
  let t7;
  $[33] !== t5 || $[34] !== t6 ? (t7 = {
    left: t5,
    top: t6,
    right: void 0,
    bottom: void 0
  }, $[33] = t5, $[34] = t6, $[35] = t7) : t7 = $[35], t4 = t7;
  const arrowStyle = t4, t8 = restProps;
  let t9;
  $[36] !== animate ? (t9 = animate ? POPOVER_MOTION_PROPS : {}, $[36] = animate, $[37] = t9) : t9 = $[37];
  let t10;
  $[38] !== padding || $[39] !== children ? (t10 = /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, padding, children }), $[38] = padding, $[39] = children, $[40] = t10) : t10 = $[40];
  let t11;
  $[41] !== overflow || $[42] !== t10 ? (t11 = /* @__PURE__ */ jsx(Flex, { "data-ui": "Popover__wrapper", direction: "column", flex: 1, overflow, children: t10 }), $[41] = overflow, $[42] = t10, $[43] = t11) : t11 = $[43];
  let t12;
  $[44] !== arrow2 || $[45] !== arrowRef || $[46] !== arrowStyle ? (t12 = arrow2 && /* @__PURE__ */ jsx(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_POPOVER_ARROW_WIDTH, height: DEFAULT_POPOVER_ARROW_HEIGHT, radius: DEFAULT_POPOVER_ARROW_RADIUS }), $[44] = arrow2, $[45] = arrowRef, $[46] = arrowStyle, $[47] = t12) : t12 = $[47];
  let t13;
  return $[48] !== t8 || $[49] !== placement || $[50] !== radius || $[51] !== ref || $[52] !== scheme || $[53] !== shadow || $[54] !== rootStyle2 || $[55] !== tone || $[56] !== t9 || $[57] !== t11 || $[58] !== t12 ? (t13 = /* @__PURE__ */ jsxs(MotionCard$1, { "data-ui": "Popover", ...t8, "data-placement": placement, radius, ref, scheme, shadow, sizing: "border", style: rootStyle2, tone, ...t9, children: [
    t11,
    t12
  ] }), $[48] = t8, $[49] = placement, $[50] = radius, $[51] = ref, $[52] = scheme, $[53] = shadow, $[54] = rootStyle2, $[55] = tone, $[56] = t9, $[57] = t11, $[58] = t12, $[59] = t13) : t13 = $[59], t13;
}));
PopoverCard.displayName = "Memo(ForwardRef(PopoverCard))";
const Popover = memo(forwardRef(function(props, forwardedRef) {
  const {
    container,
    layer
  } = useTheme_v2(), boundaryElementContext = useBoundaryElement(), {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    animate: _animate = !1,
    arrow: arrowProp = !1,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = !1,
    content,
    disabled,
    fallbackPlacements = props.fallbackPlacements ?? DEFAULT_FALLBACK_PLACEMENTS$1[props.placement ?? "bottom"],
    matchReferenceWidth,
    floatingBoundary = props.boundaryElement ?? boundaryElementContext.element,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onActivate,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = !0,
    radius: radiusProp = 3,
    referenceBoundary = props.boundaryElement ?? boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = layer.popover.zOffset,
    updateRef,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, boundarySize = useElementSize(boundaryElement)?.border, padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), widthArrayProp = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), ref = useRef(null), arrowRef = useRef(null), rootBoundary = "viewport";
  useImperativeHandle(forwardedRef, () => ref.current);
  const mediaIndex = useMediaIndex(), boundaryWidth = constrainSize || preventOverflow ? boundarySize?.width : void 0, width = calcCurrentWidth({
    container,
    mediaIndex,
    width: widthArrayProp
  }), widthRef = useRef(width);
  useEffect(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  }), maxWidthRef = useRef(maxWidth);
  useEffect(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = useRef();
  useEffect(() => {
    const floatingElement = ref.current;
    if (!open || !floatingElement) return;
    const referenceWidth = referenceWidthRef.current;
    matchReferenceWidth ? referenceWidth !== void 0 && (floatingElement.style.width = `${referenceWidth}px`) : width !== void 0 && (floatingElement.style.width = `${width}px`), typeof maxWidth == "number" && (floatingElement.style.maxWidth = `${maxWidth}px`);
  }, [width, matchReferenceWidth, maxWidth, open]);
  const middleware = useMemo(() => {
    const ret = [];
    return (constrainSize || preventOverflow) && ret.push(flip({
      boundary: floatingBoundary || void 0,
      fallbackPlacements,
      padding: DEFAULT_POPOVER_PADDING,
      rootBoundary
    })), ret.push(offset({
      mainAxis: DEFAULT_POPOVER_DISTANCE
    })), (constrainSize || matchReferenceWidth) && ret.push(size({
      apply({
        availableWidth,
        availableHeight,
        elements,
        referenceWidth: referenceWidth_0
      }) {
        referenceWidthRef.current = referenceWidth_0;
        const _currentWidth = widthRef.current, _maxWidth = maxWidthRef.current;
        matchReferenceWidth ? elements.floating.style.width = `${referenceWidth_0}px` : _currentWidth !== void 0 && (elements.floating.style.width = `${_currentWidth}px`), constrainSize && (elements.floating.style.maxWidth = `${Math.min(availableWidth, _maxWidth ?? 1 / 0)}px`, elements.floating.style.maxHeight = `${availableHeight}px`);
      },
      boundaryElement: floatingBoundary || void 0,
      constrainSize,
      margins,
      matchReferenceWidth,
      padding: DEFAULT_POPOVER_PADDING
    })), preventOverflow && ret.push(shift({
      boundary: floatingBoundary || void 0,
      rootBoundary,
      padding: DEFAULT_POPOVER_PADDING
    })), arrowProp && ret.push(arrow({
      element: arrowRef,
      padding: DEFAULT_POPOVER_PADDING
    })), animate && ret.push(origin), ret.push(hide({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    })), ret;
  }, [animate, arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]), {
    x,
    y,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  }), referenceHidden = middlewareData.hide?.referenceHidden, arrowX = middlewareData.arrow?.x, arrowY = middlewareData.arrow?.y, originX = middlewareData["@sanity/ui/origin"]?.originX, originY = middlewareData["@sanity/ui/origin"]?.originY, setArrow = useCallback((arrowEl) => {
    arrowRef.current = arrowEl;
  }, []), setFloating = useCallback((node) => {
    ref.current = node, refs.setFloating(node);
  }, [refs]), setReference = useCallback((node_0) => {
    refs.setReference(node_0);
    const childRef = getElementRef(childProp);
    typeof childRef == "function" ? childRef(node_0) : childRef && (childRef.current = node_0);
  }, [childProp, refs]), child = useMemo(() => !childProp || referenceElement ? null : cloneElement(childProp, {
    ref: setReference
  }), [childProp, referenceElement, setReference]);
  if (useEffect(() => {
    updateRef && (typeof updateRef == "function" ? updateRef(update) : updateRef && (updateRef.current = update));
  }, [update, updateRef]), useEffect(() => {
    child || refs.setReference(referenceElement || null);
  }, [referenceElement, refs, child]), disabled)
    return childProp || /* @__PURE__ */ jsx(Fragment, {});
  const popover = /* @__PURE__ */ jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsx(PopoverCard, { ...restProps, __unstable_margins: margins, animate, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, hidden: referenceHidden, overflow, padding, placement, radius, ref: setFloating, scheme, shadow, originX, originY, strategy, tone, width: matchReferenceWidth ? referenceWidthRef.current : width, x, y, children: content }) }), children = open && (portal ? /* @__PURE__ */ jsx(Portal, { __unstable_name: typeof portal == "string" ? portal : void 0, children: popover }) : popover);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    animate ? /* @__PURE__ */ jsx(AnimatePresence, { children }) : children,
    child
  ] });
}));
Popover.displayName = "Memo(ForwardRef(Popover))";
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  return mayWarn ? element.ref : (getter = Object.getOwnPropertyDescriptor(element, "ref")?.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
}
function radioBaseStyle() {
  return css`
    position: relative;

    &:not([hidden]) {
      display: inline-block;
    }

    &[data-read-only] {
      outline: 1px solid red;
    }
  `;
}
function inputElementStyle(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme), dist = (input.radio.size - input.radio.markSize) / 2;
  return css`
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    z-index: 1;
    padding: 0;
    margin: 0;
    border-radius: ${rem(input.radio.size / 2)};
    border: none;

    /* enabled */
    & + span {
      display: block;
      position: relative;
      height: ${rem(input.radio.size)};
      width: ${rem(input.radio.size)};
      border-radius: ${rem(input.radio.size / 2)};
      background: ${color.input.default.enabled.bg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

      &::after {
        content: '';
        position: absolute;
        top: ${rem(dist)};
        left: ${rem(dist)};
        height: ${rem(input.radio.markSize)};
        width: ${rem(input.radio.markSize)};
        border-radius: ${rem(input.radio.markSize / 2)};
        background: ${color.input.default.enabled.fg};
        opacity: 0;
      }
    }

    /* focused */
    &:not(:disabled):focus + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.default.enabled.border
    },
    focusRing: input.radio.focusRing
  })};
    }

    &:not(:disabled):focus:not(:focus-visible) + span {
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};
    }

    &:checked + span::after {
      opacity: 1;
    }

    /* customValidity */
    &[data-error] + span {
      background-color: ${color.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  })};
      &::after {
        background: ${color.input.invalid.enabled.muted.bg};
      }
    }

    /* read only */
    &[data-read-only] + span {
      box-shadow: 0 0 0 1px ${color.input.default.readOnly.border};
      background: ${color.input.default.readOnly.bg};

      &::after {
        background: ${color.input.default.readOnly.border};
      }
    }

    /* disabled */
    &:not([data-read-only]):disabled + span {
      box-shadow: 0 0 0 1px ${color.input.default.disabled.border};
      background: ${color.input.default.disabled.bg};

      &::after {
        background: ${color.input.default.disabled.border};
      }
    }
  `;
}
const Root$g = styled.div(radioBaseStyle), Input$4 = styled.input(inputElementStyle), Radio = forwardRef(function(props, forwardedRef) {
  const $ = c(19);
  let customValidity, disabled, readOnly, restProps, className, style;
  $[0] !== props ? ({
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props, $[0] = props, $[1] = customValidity, $[2] = disabled, $[3] = readOnly, $[4] = restProps, $[5] = className, $[6] = style) : (customValidity = $[1], disabled = $[2], readOnly = $[3], restProps = $[4], className = $[5], style = $[6]);
  const ref = useRef(null);
  let t0;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $[7] = t0) : t0 = $[7], useImperativeHandle(forwardedRef, t0), useCustomValidity(ref, customValidity);
  const t1 = !disabled && readOnly ? "" : void 0, t2 = customValidity ? "" : void 0, t3 = disabled || readOnly;
  let t4;
  $[8] !== t1 || $[9] !== t2 || $[10] !== restProps || $[11] !== t3 || $[12] !== readOnly ? (t4 = /* @__PURE__ */ jsx(Input$4, { "data-read-only": t1, "data-error": t2, ...restProps, disabled: t3, readOnly, ref, type: "radio" }), $[8] = t1, $[9] = t2, $[10] = restProps, $[11] = t3, $[12] = readOnly, $[13] = t4) : t4 = $[13];
  let t5;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t5 = /* @__PURE__ */ jsx("span", {}), $[14] = t5) : t5 = $[14];
  let t6;
  return $[15] !== className || $[16] !== style || $[17] !== t4 ? (t6 = /* @__PURE__ */ jsxs(Root$g, { className, "data-ui": "Radio", style, children: [
    t4,
    t5
  ] }), $[15] = className, $[16] = style, $[17] = t4, $[18] = t6) : t6 = $[18], t6;
});
Radio.displayName = "ForwardRef(Radio)";
function rootStyle() {
  return css`
    position: relative;
    width: -moz-available;
    width: -webkit-fill-available;
    width: stretch;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function inputBaseStyle(props) {
  const {
    font
  } = getTheme_v2(props.theme);
  return css`
    -webkit-font-smoothing: antialiased;
    appearance: none;
    border: 0;
    font-family: ${font.text.family};
    color: inherit;
    width: 100%;
    outline: none;
    margin: 0;

    &:disabled {
      opacity: 1;
    }
  `;
}
function inputColorStyle(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  return css`
    /* enabled */
    background-color: ${color.input.default.enabled.bg};
    color: ${color.input.default.enabled.fg};
    box-shadow: ${focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  })};

    /* hovered */
    @media (hover: hover) {
      &:not(:disabled):hover {
        background-color: ${color.input.default.hovered.bg};
        color: ${color.input.default.hovered.fg};
        box-shadow: ${focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  })};
      }
    }

    /* focused */
    &:not(:disabled):focus {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.default.enabled.border
    },
    focusRing: input.select.focusRing
  })};
    }

    /* read-only */
    &[data-read-only] {
      background-color: ${color.input.default.readOnly.bg};
      color: ${color.input.default.readOnly.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.readOnly.border,
    width: input.border.width
  })};
    }

    /* disabled */
    &:not([data-read-only]):disabled {
      background-color: ${color.input.default.disabled.bg};
      color: ${color.input.default.disabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  })};
    }
  `;
}
function textSize(size2) {
  return {
    fontSize: rem(size2.fontSize),
    lineHeight: rem(size2.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    $fontSize
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, $fontSize, (sizeIndex) => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    color
  } = getTheme_v2(props.theme);
  return css`
    pointer-events: none;
    position: absolute;
    top: 0;
    right: 0;

    /* enabled */
    --card-fg-color: ${color.input.default.enabled.fg};

    /* hover */
    @media (hover: hover) {
      select:not(disabled):not(:read-only):hover + && {
        --card-fg-color: ${color.input.default.hovered.fg};
      }
    }

    /* disabled */
    select:disabled + && {
      --card-fg-color: ${color.input.default.disabled.fg};
    }

    /* read-only */
    select[data-read-only] + && {
      --card-fg-color: ${color.input.default.readOnly.fg};
    }
  `;
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
}, Root$f = styled.div(selectStyle.root), Input$3 = styled.select(selectStyle.input), IconBox = styled(Box)(selectStyle.iconBox), Select = forwardRef(function(props, forwardedRef) {
  const $ = c(29);
  let t0, t1, t2, t3, customValidity, disabled, readOnly, restProps, children;
  $[0] !== props ? ({
    children,
    customValidity,
    disabled,
    fontSize: t0,
    padding: t1,
    radius: t2,
    readOnly,
    space: t3,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = customValidity, $[6] = disabled, $[7] = readOnly, $[8] = restProps, $[9] = children) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], customValidity = $[5], disabled = $[6], readOnly = $[7], restProps = $[8], children = $[9]);
  const fontSize2 = t0 === void 0 ? 2 : t0, padding = t1 === void 0 ? 3 : t1, radius = t2 === void 0 ? 2 : t2, space = t3 === void 0 ? 3 : t3, ref = useRef(null);
  let t4;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $[10] = t4) : t4 = $[10], useImperativeHandle(forwardedRef, t4), useCustomValidity(ref, customValidity);
  const t5 = !disabled && readOnly ? "" : void 0, t6 = useArrayProp(fontSize2), t7 = useArrayProp(padding), t8 = useArrayProp(radius), t9 = useArrayProp(space), t10 = disabled || readOnly;
  let t11;
  $[11] !== t5 || $[12] !== restProps || $[13] !== t6 || $[14] !== t7 || $[15] !== t8 || $[16] !== t9 || $[17] !== t10 || $[18] !== children ? (t11 = /* @__PURE__ */ jsx(Input$3, { "data-read-only": t5, "data-ui": "Select", ...restProps, $fontSize: t6, $padding: t7, $radius: t8, $space: t9, disabled: t10, ref, children }), $[11] = t5, $[12] = restProps, $[13] = t6, $[14] = t7, $[15] = t8, $[16] = t9, $[17] = t10, $[18] = children, $[19] = t11) : t11 = $[19];
  let t12;
  $[20] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(ChevronDownIcon, {}), $[20] = t12) : t12 = $[20];
  let t13;
  $[21] !== fontSize2 ? (t13 = /* @__PURE__ */ jsx(Text, { size: fontSize2, children: t12 }), $[21] = fontSize2, $[22] = t13) : t13 = $[22];
  let t14;
  $[23] !== padding || $[24] !== t13 ? (t14 = /* @__PURE__ */ jsx(IconBox, { padding, children: t13 }), $[23] = padding, $[24] = t13, $[25] = t14) : t14 = $[25];
  let t15;
  return $[26] !== t11 || $[27] !== t14 ? (t15 = /* @__PURE__ */ jsxs(Root$f, { "data-ui": "Select", children: [
    t11,
    t14
  ] }), $[26] = t11, $[27] = t14, $[28] = t15) : t15 = $[28], t15;
});
Select.displayName = "ForwardRef(Select)";
const BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
const Root$e = styled(Box)(stackBaseStyle, responsiveStackSpaceStyle), Stack = forwardRef(function(props, ref) {
  const $ = c(10);
  let as, space, restProps;
  $[0] !== props ? ({
    as,
    space,
    ...restProps
  } = props, $[0] = props, $[1] = as, $[2] = space, $[3] = restProps) : (as = $[1], space = $[2], restProps = $[3]);
  const t0 = typeof as == "string" ? as : void 0, t1 = useArrayProp(space);
  let t2;
  return $[4] !== t0 || $[5] !== restProps || $[6] !== t1 || $[7] !== as || $[8] !== ref ? (t2 = /* @__PURE__ */ jsx(Root$e, { "data-as": t0, "data-ui": "Stack", ...restProps, $space: t1, forwardedAs: as, ref }), $[4] = t0, $[5] = restProps, $[6] = t1, $[7] = as, $[8] = ref, $[9] = t2) : t2 = $[9], t2;
});
Stack.displayName = "ForwardRef(Stack)";
function switchBaseStyles() {
  return css`
    position: relative;
    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function switchInputStyles() {
  return css`
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
    margin: 0;

    /* Place the input element above the representation element */
    z-index: 1;
  `;
}
function switchRepresentationStyles(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  return css`
    --switch-bg-color: ${color.input.default.enabled.border};
    --switch-fg-color: ${color.input.default.enabled.bg};
    --switch-box-shadow: none;

    &:not([hidden]) {
      display: block;
    }
    position: relative;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};

    /* Make sure itâ€™s not possible to interact with the wrapper element */
    pointer-events: none;

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      box-shadow: var(--switch-box-shadow);
      border-radius: inherit;
    }

    /* Focus styles */
    input:focus + && {
      --switch-box-shadow: ${focusRingStyle({
    focusRing: input.switch.focusRing
  })};
    }

    input:focus:not(:focus-visible) + && {
      --switch-box-shadow: none;
    }

    input:checked + && {
      --switch-bg-color: ${color.input.default.enabled.fg};
      --switch-fg-color: ${color.input.default.enabled.bg};
    }

    @media (hover: hover) {
      input:not(:disabled):hover + && {
        --switch-bg-color: ${color.input.default.hovered.border};
        --switch-fg-color: ${color.input.default.hovered.bg};
      }

      input:not(:disabled):checked:hover + && {
        --switch-bg-color: ${color.input.default.enabled.fg};
        --switch-fg-color: ${color.input.default.enabled.bg};
      }
    }

    input:not([data-read-only]):disabled + && {
      --switch-bg-color: ${color.input.default.disabled.border};
      --switch-fg-color: ${color.input.default.disabled.bg};
    }

    input[data-read-only]:disabled + && {
      --switch-bg-color: ${color.input.default.readOnly.border};
      --switch-fg-color: ${color.input.default.readOnly.bg};
    }

    input:checked[data-read-only]:disabled + && {
      --switch-bg-color: ${color.input.default.readOnly.fg};
      --switch-fg-color: ${color.input.default.readOnly.bg};
    }
  `;
}
function switchTrackStyles(props) {
  const {
    input
  } = getTheme_v2(props.theme);
  return css`
    &:not([hidden]) {
      display: block;
    }
    background-color: var(--switch-bg-color);
    position: absolute;
    left: 0;
    top: 0;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};
  `;
}
function switchThumbStyles(props) {
  const {
    $indeterminate
  } = props, {
    input
  } = getTheme_v2(props.theme), trackWidth = input.switch.width, trackHeight = input.switch.height, trackPadding = input.switch.padding, size2 = trackHeight - input.switch.padding * 2, checkedOffset = trackWidth - trackPadding * 2 - size2, indeterminateOffset = trackWidth / 2 - size2 / 2 - trackPadding, checked = $indeterminate !== !0 && props.$checked === !0;
  return css`
    &:not([hidden]) {
      display: block;
    }
    position: absolute;
    left: ${rem(trackPadding)};
    top: ${rem(trackPadding)};
    height: ${rem(size2)};
    width: ${rem(size2)};
    border-radius: ${rem(size2 / 2)};
    transition-property: transform;
    transition-duration: ${input.switch.transitionDurationMs}ms;
    transition-timing-function: ${input.switch.transitionTimingFunction};
    background: var(--switch-fg-color);
    transform: translate3d(0, 0, 0);
    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);

    ${checked && css`
      transform: translate3d(${checkedOffset}px, 0, 0);
    `}

    ${$indeterminate && css`
      transform: translate3d(${indeterminateOffset}px, 0, 0);
    `}
  `;
}
const Root$d = styled.span(switchBaseStyles), Input$2 = styled.input(switchInputStyles), Representation = styled.span(switchRepresentationStyles), Track = styled.span(switchTrackStyles), Thumb = styled.span(switchThumbStyles), Switch = forwardRef(function(props, forwardedRef) {
  const $ = c(26);
  let indeterminate, disabled, readOnly, checked, restProps, className, style;
  $[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props, $[0] = props, $[1] = indeterminate, $[2] = disabled, $[3] = readOnly, $[4] = checked, $[5] = restProps, $[6] = className, $[7] = style) : (indeterminate = $[1], disabled = $[2], readOnly = $[3], checked = $[4], restProps = $[5], className = $[6], style = $[7]);
  const ref = useRef(null);
  let t0;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $[8] = t0) : t0 = $[8], useImperativeHandle(forwardedRef, t0);
  let t1, t2;
  $[9] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, t2 = [indeterminate], $[9] = indeterminate, $[10] = t1, $[11] = t2) : (t1 = $[10], t2 = $[11]), useEffect(t1, t2);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = indeterminate !== !0 && checked, t5 = disabled || readOnly;
  let t6;
  $[12] !== t3 || $[13] !== restProps || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ jsx(Input$2, { "data-read-only": t3, ...restProps, checked: t4, disabled: t5, type: "checkbox", ref }), $[12] = t3, $[13] = restProps, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] === Symbol.for("react.memo_cache_sentinel") ? (t7 = /* @__PURE__ */ jsx(Track, {}), $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== checked || $[19] !== indeterminate ? (t8 = /* @__PURE__ */ jsxs(Representation, { "aria-hidden": !0, "data-name": "representation", children: [
    t7,
    /* @__PURE__ */ jsx(Thumb, { $checked: checked, $indeterminate: indeterminate })
  ] }), $[18] = checked, $[19] = indeterminate, $[20] = t8) : t8 = $[20];
  let t9;
  return $[21] !== className || $[22] !== style || $[23] !== t6 || $[24] !== t8 ? (t9 = /* @__PURE__ */ jsxs(Root$d, { className, "data-ui": "Switch", style, children: [
    t6,
    t8
  ] }), $[21] = className, $[22] = style, $[23] = t6, $[24] = t8, $[25] = t9) : t9 = $[25], t9;
});
Switch.displayName = "ForwardRef(Switch)";
const Root$c = styled.span(textInputRootStyle), InputRoot$1 = styled.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Input$1 = styled.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle), Presentation$1 = styled.div(responsiveRadiusStyle, textInputRepresentationStyle), TextArea = forwardRef(function(props, forwardedRef) {
  const $ = c(29);
  let t0, t1, t2, t3, t4, customValidity, restProps, weight, __unstable_disableFocusRing;
  $[0] !== props ? ({
    border: t0,
    customValidity,
    disabled: t1,
    fontSize: t2,
    padding: t3,
    radius: t4,
    weight,
    __unstable_disableFocusRing,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = customValidity, $[7] = restProps, $[8] = weight, $[9] = __unstable_disableFocusRing) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], customValidity = $[6], restProps = $[7], weight = $[8], __unstable_disableFocusRing = $[9]);
  const border2 = t0 === void 0 ? !0 : t0, disabled = t1 === void 0 ? !1 : t1, fontSize2 = t2 === void 0 ? 2 : t2, padding = t3 === void 0 ? 3 : t3, radius = t4 === void 0 ? 2 : t4, ref = useRef(null), rootTheme = useRootTheme();
  let t5;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $[10] = t5) : t5 = $[10], useImperativeHandle(forwardedRef, t5), useCustomValidity(ref, customValidity);
  const t6 = rootTheme.scheme, t7 = rootTheme.tone, t8 = useArrayProp(fontSize2), t9 = useArrayProp(padding), t10 = rootTheme.scheme, t11 = useArrayProp(0);
  let t12;
  $[11] !== rootTheme.scheme || $[12] !== rootTheme.tone || $[13] !== restProps || $[14] !== t8 || $[15] !== t9 || $[16] !== t11 || $[17] !== weight || $[18] !== disabled ? (t12 = /* @__PURE__ */ jsx(Input$1, { "data-as": "textarea", "data-scheme": t6, "data-tone": t7, ...restProps, $fontSize: t8, $padding: t9, $scheme: t10, $space: t11, $tone: rootTheme.tone, $weight: weight, disabled, ref }), $[11] = rootTheme.scheme, $[12] = rootTheme.tone, $[13] = restProps, $[14] = t8, $[15] = t9, $[16] = t11, $[17] = weight, $[18] = disabled, $[19] = t12) : t12 = $[19];
  const t13 = useArrayProp(radius), t14 = border2 ? "" : void 0;
  let t15;
  $[20] !== t13 || $[21] !== __unstable_disableFocusRing || $[22] !== rootTheme.scheme || $[23] !== rootTheme.tone || $[24] !== t14 ? (t15 = /* @__PURE__ */ jsx(Presentation$1, { $radius: t13, $unstableDisableFocusRing: __unstable_disableFocusRing, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t14, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone }), $[20] = t13, $[21] = __unstable_disableFocusRing, $[22] = rootTheme.scheme, $[23] = rootTheme.tone, $[24] = t14, $[25] = t15) : t15 = $[25];
  let t16;
  return $[26] !== t12 || $[27] !== t15 ? (t16 = /* @__PURE__ */ jsx(Root$c, { "data-ui": "TextArea", children: /* @__PURE__ */ jsxs(InputRoot$1, { children: [
    t12,
    t15
  ] }) }), $[26] = t12, $[27] = t15, $[28] = t16) : t16 = $[28], t16;
});
TextArea.displayName = "ForwardRef(TextArea)";
const CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
}, Root$b = styled(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle), InputRoot = styled.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Prefix = styled(Card).attrs({
  forwardedAs: "span"
})`
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Suffix = styled(Card).attrs({
  forwardedAs: "span"
})`
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Input = styled.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle), Presentation = styled.span(responsiveRadiusStyle, textInputRepresentationStyle), LeftBox = styled(Box)`
  position: absolute;
  top: 0;
  left: 0;
`, RightBox = styled(Box)`
  position: absolute;
  top: 0;
  right: 0;
`, RightCard = styled(Card)`
  background-color: transparent;
  position: absolute;
  top: 0;
  right: 0;
`, TextInputClearButton = styled(Button)({
  "&:not([hidden])": {
    display: "block"
  }
}), TextInput = forwardRef(function(props, forwardedRef) {
  const $ = c(86);
  let t0, t1, t2, t3, t4, t5, t6, clearButton, IconComponent, IconRightComponent, suffix, prefix, customValidity, onClear, __unstable_disableFocusRing, readOnly, restProps, weight;
  $[0] !== props ? ({
    __unstable_disableFocusRing,
    border: t0,
    clearButton,
    disabled: t1,
    fontSize: t2,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClear,
    padding: t3,
    prefix,
    radius: t4,
    readOnly,
    space: t5,
    suffix,
    customValidity,
    type: t6,
    weight,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = t5, $[7] = t6, $[8] = clearButton, $[9] = IconComponent, $[10] = IconRightComponent, $[11] = suffix, $[12] = prefix, $[13] = customValidity, $[14] = onClear, $[15] = __unstable_disableFocusRing, $[16] = readOnly, $[17] = restProps, $[18] = weight) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], t5 = $[6], t6 = $[7], clearButton = $[8], IconComponent = $[9], IconRightComponent = $[10], suffix = $[11], prefix = $[12], customValidity = $[13], onClear = $[14], __unstable_disableFocusRing = $[15], readOnly = $[16], restProps = $[17], weight = $[18]);
  const border2 = t0 === void 0 ? !0 : t0, disabled = t1 === void 0 ? !1 : t1, fontSizeProp = t2 === void 0 ? 2 : t2, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, type = t6 === void 0 ? "text" : t6, ref = useRef(null), rootTheme = useRootTheme(), fontSize2 = useArrayProp(fontSizeProp), padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp), $hasClearButton = !!clearButton, $hasIcon = !!IconComponent, $hasIconRight = !!IconRightComponent, $hasSuffix = !!suffix, $hasPrefix = !!prefix;
  let t7;
  $[19] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => ref.current, $[19] = t7) : t7 = $[19], useImperativeHandle(forwardedRef, t7), useCustomValidity(ref, customValidity);
  const handleClearMouseDown = _temp$2;
  let t8;
  $[20] !== onClear ? (t8 = (event_0) => {
    event_0.preventDefault(), event_0.stopPropagation(), onClear && onClear(), ref.current?.focus();
  }, $[20] = onClear, $[21] = t8) : t8 = $[21];
  const handleClearClick = t8;
  let t9, t10;
  $[22] !== prefix || $[23] !== radius ? (t10 = prefix && /* @__PURE__ */ jsx(Prefix, { borderTop: !0, borderLeft: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsx("span", { children: prefix }) }), $[22] = prefix, $[23] = radius, $[24] = t10) : t10 = $[24], t9 = t10;
  const prefixNode = t9;
  let t11;
  const t12 = border2 ? "" : void 0;
  let t13;
  $[25] !== IconComponent || $[26] !== fontSize2 || $[27] !== padding ? (t13 = IconComponent && /* @__PURE__ */ jsx(LeftBox, { padding, children: /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
    isValidElement(IconComponent) && IconComponent,
    isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
  ] }) }), $[25] = IconComponent, $[26] = fontSize2, $[27] = padding, $[28] = t13) : t13 = $[28];
  let t14;
  $[29] !== $hasClearButton || $[30] !== IconRightComponent || $[31] !== fontSize2 || $[32] !== padding ? (t14 = !$hasClearButton && IconRightComponent && /* @__PURE__ */ jsx(RightBox, { padding, children: /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
    isValidElement(IconRightComponent) && IconRightComponent,
    isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
  ] }) }), $[29] = $hasClearButton, $[30] = IconRightComponent, $[31] = fontSize2, $[32] = padding, $[33] = t14) : t14 = $[33];
  let t15;
  $[34] !== $hasPrefix || $[35] !== __unstable_disableFocusRing || $[36] !== $hasSuffix || $[37] !== radius || $[38] !== rootTheme.scheme || $[39] !== rootTheme.tone || $[40] !== t12 || $[41] !== t13 || $[42] !== t14 ? (t15 = /* @__PURE__ */ jsxs(Presentation, { $hasPrefix, $unstableDisableFocusRing: __unstable_disableFocusRing, $hasSuffix, $radius: radius, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t12, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, children: [
    t13,
    t14
  ] }), $[34] = $hasPrefix, $[35] = __unstable_disableFocusRing, $[36] = $hasSuffix, $[37] = radius, $[38] = rootTheme.scheme, $[39] = rootTheme.tone, $[40] = t12, $[41] = t13, $[42] = t14, $[43] = t15) : t15 = $[43], t11 = t15;
  const presentationNode = t11;
  let t16, t17;
  if ($[44] !== padding) {
    let t182;
    $[46] === Symbol.for("react.memo_cache_sentinel") ? (t182 = (v) => v === 0 ? 0 : v === 1 || v === 2 ? 1 : v - 2, $[46] = t182) : t182 = $[46], t17 = padding.map(t182), $[44] = padding, $[45] = t17;
  } else
    t17 = $[45];
  t16 = t17;
  const clearButtonBoxPadding = t16;
  let t18, t19;
  if ($[47] !== padding) {
    let t202;
    $[49] === Symbol.for("react.memo_cache_sentinel") ? (t202 = (v_0) => v_0 === 0 || v_0 === 1 ? 0 : v_0 === 2 ? 1 : v_0 - 1, $[49] = t202) : t202 = $[49], t19 = padding.map(t202), $[47] = padding, $[48] = t19;
  } else
    t19 = $[48];
  t18 = t19;
  const clearButtonPadding = t18;
  let t20;
  t20 = typeof clearButton == "object" ? clearButton : EMPTY_RECORD;
  const clearButtonProps = t20;
  let t21, t22;
  $[50] !== disabled || $[51] !== readOnly || $[52] !== clearButton || $[53] !== customValidity || $[54] !== fontSize2 || $[55] !== clearButtonPadding || $[56] !== radius || $[57] !== clearButtonProps || $[58] !== handleClearClick || $[59] !== clearButtonBoxPadding ? (t22 = !disabled && !readOnly && clearButton && /* @__PURE__ */ jsx(RightCard, { forwardedAs: "span", padding: clearButtonBoxPadding, style: CLEAR_BUTTON_BOX_STYLE, tone: customValidity ? "critical" : "inherit", children: /* @__PURE__ */ jsx(TextInputClearButton, { "aria-label": "Clear", "data-qa": "clear-button", fontSize: fontSize2, icon: CloseIcon, mode: "bleed", padding: clearButtonPadding, radius, ...clearButtonProps, onClick: handleClearClick, onMouseDown: handleClearMouseDown }) }), $[50] = disabled, $[51] = readOnly, $[52] = clearButton, $[53] = customValidity, $[54] = fontSize2, $[55] = clearButtonPadding, $[56] = radius, $[57] = clearButtonProps, $[58] = handleClearClick, $[59] = clearButtonBoxPadding, $[60] = t22) : t22 = $[60], t21 = t22;
  const clearButtonNode = t21;
  let t23, t24;
  $[61] !== suffix || $[62] !== radius ? (t24 = suffix && /* @__PURE__ */ jsx(Suffix, { borderTop: !0, borderRight: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsx("span", { children: suffix }) }), $[61] = suffix, $[62] = radius, $[63] = t24) : t24 = $[63], t23 = t24;
  const suffixNode = t23, t25 = $hasIconRight || $hasClearButton;
  let t26;
  $[64] !== rootTheme.scheme || $[65] !== rootTheme.tone || $[66] !== restProps || $[67] !== fontSize2 || $[68] !== $hasIcon || $[69] !== t25 || $[70] !== padding || $[71] !== space || $[72] !== weight || $[73] !== disabled || $[74] !== readOnly || $[75] !== type ? (t26 = /* @__PURE__ */ jsx(Input, { "data-as": "input", "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, ...restProps, $fontSize: fontSize2, $iconLeft: $hasIcon, $iconRight: t25, $padding: padding, $scheme: rootTheme.scheme, $space: space, $tone: rootTheme.tone, $weight: weight, disabled, readOnly, ref, type }), $[64] = rootTheme.scheme, $[65] = rootTheme.tone, $[66] = restProps, $[67] = fontSize2, $[68] = $hasIcon, $[69] = t25, $[70] = padding, $[71] = space, $[72] = weight, $[73] = disabled, $[74] = readOnly, $[75] = type, $[76] = t26) : t26 = $[76];
  let t27;
  $[77] !== t26 || $[78] !== presentationNode || $[79] !== clearButtonNode ? (t27 = /* @__PURE__ */ jsxs(InputRoot, { children: [
    t26,
    presentationNode,
    clearButtonNode
  ] }), $[77] = t26, $[78] = presentationNode, $[79] = clearButtonNode, $[80] = t27) : t27 = $[80];
  let t28;
  return $[81] !== rootTheme.tone || $[82] !== prefixNode || $[83] !== t27 || $[84] !== suffixNode ? (t28 = /* @__PURE__ */ jsxs(Root$b, { "data-ui": "TextInput", tone: rootTheme.tone, children: [
    prefixNode,
    t27,
    suffixNode
  ] }), $[81] = rootTheme.tone, $[82] = prefixNode, $[83] = t27, $[84] = suffixNode, $[85] = t28) : t28 = $[85], t28;
});
TextInput.displayName = "ForwardRef(TextInput)";
function _temp$2(event) {
  event.preventDefault(), event.stopPropagation();
}
function useDelayedState(initialState) {
  const $ = c(3), [state, setState] = useState(initialState), delayedAction = useRef();
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (nextState, delay) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current && (clearTimeout(delayedAction.current), delayedAction.current = void 0), !delay)
      return action();
    delayedAction.current = setTimeout(action, delay);
  }, $[0] = t0) : t0 = $[0];
  const onStateChange = t0;
  let t1;
  return $[1] !== state ? (t1 = [state, onStateChange], $[1] = state, $[2] = t1) : t1 = $[2], t1;
}
const DEFAULT_TOOLTIP_ARROW_WIDTH = 15, DEFAULT_TOOLTIP_ARROW_HEIGHT = 6, DEFAULT_TOOLTIP_ARROW_RADIUS = 2, DEFAULT_TOOLTIP_DISTANCE = 4, DEFAULT_TOOLTIP_PADDING = 4, DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
}, MotionCard = styled(motion(Card))`
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, TooltipCard = memo(forwardRef(function(props, ref) {
  const $ = c(42);
  let animate, originX, originY, style, arrowX, arrowY, restProps, arrow2, arrowRef, placement, padding, radius, scheme, shadow, children;
  $[0] !== props ? ({
    animate,
    arrow: arrow2,
    arrowRef,
    arrowX,
    arrowY,
    children,
    originX,
    originY,
    padding,
    placement,
    radius,
    scheme,
    shadow,
    style,
    ...restProps
  } = props, $[0] = props, $[1] = animate, $[2] = originX, $[3] = originY, $[4] = style, $[5] = arrowX, $[6] = arrowY, $[7] = restProps, $[8] = arrow2, $[9] = arrowRef, $[10] = placement, $[11] = padding, $[12] = radius, $[13] = scheme, $[14] = shadow, $[15] = children) : (animate = $[1], originX = $[2], originY = $[3], style = $[4], arrowX = $[5], arrowY = $[6], restProps = $[7], arrow2 = $[8], arrowRef = $[9], placement = $[10], padding = $[11], radius = $[12], scheme = $[13], shadow = $[14], children = $[15]);
  let t0;
  const t1 = animate ? "transform" : void 0;
  let t2;
  $[16] !== originX || $[17] !== originY || $[18] !== t1 || $[19] !== style ? (t2 = {
    originX,
    originY,
    willChange: t1,
    ...style
  }, $[16] = originX, $[17] = originY, $[18] = t1, $[19] = style, $[20] = t2) : t2 = $[20], t0 = t2;
  const rootStyle2 = t0;
  let t3;
  const t4 = arrowX !== null ? arrowX : void 0, t5 = arrowY !== null ? arrowY : void 0;
  let t6;
  $[21] !== t4 || $[22] !== t5 ? (t6 = {
    left: t4,
    top: t5,
    right: void 0,
    bottom: void 0
  }, $[21] = t4, $[22] = t5, $[23] = t6) : t6 = $[23], t3 = t6;
  const arrowStyle = t3, t7 = restProps;
  let t8;
  $[24] !== animate ? (t8 = animate ? POPOVER_MOTION_PROPS : {}, $[24] = animate, $[25] = t8) : t8 = $[25];
  let t9;
  $[26] !== arrow2 || $[27] !== arrowRef || $[28] !== arrowStyle ? (t9 = arrow2 && /* @__PURE__ */ jsx(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_TOOLTIP_ARROW_WIDTH, height: DEFAULT_TOOLTIP_ARROW_HEIGHT, radius: DEFAULT_TOOLTIP_ARROW_RADIUS }), $[26] = arrow2, $[27] = arrowRef, $[28] = arrowStyle, $[29] = t9) : t9 = $[29];
  let t10;
  return $[30] !== t7 || $[31] !== placement || $[32] !== padding || $[33] !== radius || $[34] !== ref || $[35] !== scheme || $[36] !== shadow || $[37] !== rootStyle2 || $[38] !== t8 || $[39] !== children || $[40] !== t9 ? (t10 = /* @__PURE__ */ jsxs(MotionCard, { "data-ui": "Tooltip__card", ...t7, "data-placement": placement, padding, radius, ref, scheme, shadow, style: rootStyle2, ...t8, children: [
    children,
    t9
  ] }), $[30] = t7, $[31] = placement, $[32] = padding, $[33] = radius, $[34] = ref, $[35] = scheme, $[36] = shadow, $[37] = rootStyle2, $[38] = t8, $[39] = children, $[40] = t9, $[41] = t10) : t10 = $[41], t10;
}));
TooltipCard.displayName = "Memo(ForwardRef(TooltipCard))";
const TooltipDelayGroupContext = createGlobalScopedContext("@sanity/ui/context/tooltipDelayGroup", null);
function useTooltipDelayGroup() {
  return useContext(TooltipDelayGroupContext);
}
function TooltipDelayGroupProvider(props) {
  const $ = c(10), {
    children,
    delay
  } = props, [isGroupActive, setIsGroupActive] = useDelayedState(!1), [openTooltipId, setOpenTooltipId] = useDelayedState(null), openDelay = typeof delay == "number" ? delay : delay?.open || 0, closeDelay = typeof delay == "number" ? delay : delay?.close || 0;
  let t0;
  const t1 = isGroupActive ? 1 : openDelay;
  let t2;
  $[0] !== isGroupActive || $[1] !== setIsGroupActive || $[2] !== openTooltipId || $[3] !== setOpenTooltipId || $[4] !== t1 || $[5] !== closeDelay ? (t2 = {
    isGroupActive,
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    openDelay: t1,
    closeDelay
  }, $[0] = isGroupActive, $[1] = setIsGroupActive, $[2] = openTooltipId, $[3] = setOpenTooltipId, $[4] = t1, $[5] = closeDelay, $[6] = t2) : t2 = $[6], t0 = t2;
  const value = t0;
  let t3;
  return $[7] !== value || $[8] !== children ? (t3 = /* @__PURE__ */ jsx(TooltipDelayGroupContext.Provider, { value, children }), $[7] = value, $[8] = children, $[9] = t3) : t3 = $[9], t3;
}
TooltipDelayGroupProvider.displayName = "TooltipDelayGroupProvider";
const Root$a = styled(Layer)`
  pointer-events: none;
`, Tooltip = forwardRef(function(props, forwardedRef) {
  const boundaryElementContext = useBoundaryElement(), {
    layer
  } = useTheme_v2(), {
    animate: _animate = !1,
    arrow: arrowProp = !1,
    boundaryElement = boundaryElementContext?.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = props.fallbackPlacements ?? DEFAULT_FALLBACK_PLACEMENTS[props.placement ?? "bottom"],
    padding = 2,
    placement: placementProp = "bottom",
    portal: portalProp,
    radius = 2,
    scheme,
    shadow = 2,
    zOffset = layer.tooltip.zOffset,
    delay,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, fallbackPlacements = useArrayProp(fallbackPlacementsProp), ref = useRef(null), [referenceElement, setReferenceElement] = useState(null), arrowRef = useRef(null), rootBoundary = "viewport", [tooltipMaxWidth, setTooltipMaxWidth] = useState(0);
  useImperativeHandle(forwardedRef, () => ref.current);
  const portal = usePortal(), portalElement = typeof portalProp == "string" ? portal.elements?.[portalProp] || null : portal.element, middleware = useMemo(() => {
    const ret = [];
    return ret.push(flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    })), ret.push(offset({
      mainAxis: DEFAULT_TOOLTIP_DISTANCE
    })), ret.push(shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    })), arrowProp && ret.push(arrow({
      element: arrowRef,
      padding: DEFAULT_TOOLTIP_PADDING
    })), animate && ret.push(origin), ret;
  }, [animate, arrowProp, boundaryElement, fallbackPlacements]), {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  }), arrowX = middlewareData.arrow?.x, arrowY = middlewareData.arrow?.y, originX = middlewareData["@sanity/ui/origin"]?.originX, originY = middlewareData["@sanity/ui/origin"]?.originY, tooltipId = useId(), [isOpen, setIsOpen] = useDelayedState(!1), delayGroupContext = useTooltipDelayGroup(), showTooltip = isOpen || delayGroupContext?.openTooltipId === tooltipId, isInsideGroup = delayGroupContext !== null, openDelayProp = typeof delay == "number" ? delay : delay?.open || 0, closeDelayProp = typeof delay == "number" ? delay : delay?.close || 0, openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp, closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp, handleIsOpenChange = useCallback((open, immediate) => {
    if (isInsideGroup)
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        delayGroupContext.setIsGroupActive(open, groupedOpenDelay), delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
      } else {
        const groupDeactivateDelay = closeDelay > 200 ? closeDelay : 200;
        delayGroupContext.setIsGroupActive(open, groupDeactivateDelay), delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
      }
    else
      setIsOpen(open, immediate ? 0 : open ? openDelay : closeDelay);
  }, [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]), handleBlur = useCallback((e) => {
    handleIsOpenChange(!1), childProp?.props?.onBlur?.(e);
  }, [childProp?.props, handleIsOpenChange]), handleClick = useCallback((e_0) => {
    handleIsOpenChange(!1, !0), childProp?.props.onClick?.(e_0);
  }, [childProp?.props, handleIsOpenChange]), handleContextMenu = useCallback((e_1) => {
    handleIsOpenChange(!1, !0), childProp?.props.onContextMenu?.(e_1);
  }, [childProp?.props, handleIsOpenChange]), handleFocus = useCallback((e_2) => {
    handleIsOpenChange(!0), childProp?.props?.onFocus?.(e_2);
  }, [childProp?.props, handleIsOpenChange]), handleMouseEnter = useCallback((e_3) => {
    handleIsOpenChange(!0), childProp?.props?.onMouseEnter?.(e_3);
  }, [childProp?.props, handleIsOpenChange]), handleMouseLeave = useCallback((e_4) => {
    handleIsOpenChange(!1), childProp?.props?.onMouseLeave?.(e_4);
  }, [childProp?.props, handleIsOpenChange]);
  useCloseOnMouseLeave({
    handleIsOpenChange,
    referenceElement,
    showTooltip
  }), useEffect(() => {
    disabled && showTooltip && handleIsOpenChange(!1);
  }, [disabled, handleIsOpenChange, showTooltip]), useEffect(() => {
    !content && showTooltip && handleIsOpenChange(!1);
  }, [content, handleIsOpenChange, showTooltip]), useEffect(() => refs.setReference(referenceElement), [referenceElement, refs]), useEffect(() => {
    if (!showTooltip) return;
    function handleWindowKeyDown(event) {
      event.key === "Escape" && handleIsOpenChange(!1, !0);
    }
    return window.addEventListener("keydown", handleWindowKeyDown), () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]), useLayoutEffect(() => {
    const availableWidths = [...boundaryElement ? [boundaryElement.offsetWidth] : [], portalElement?.offsetWidth || document.body.offsetWidth];
    setTooltipMaxWidth(Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2);
  }, [boundaryElement, portalElement]);
  const setArrow = useCallback((arrowEl) => {
    arrowRef.current = arrowEl, update();
  }, [update]), setFloating = useCallback((node) => {
    ref.current = node, refs.setFloating(node);
  }, [refs]), childRef = useRef(null);
  useImperativeHandle(childProp?.ref, () => childRef.current);
  const child = useMemo(() => childProp ? cloneElement(childProp, {
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onContextMenu: handleContextMenu,
    ref: childRef
  }) : null, [childProp, handleBlur, handleClick, handleContextMenu, handleFocus, handleMouseEnter, handleMouseLeave]);
  if (useEffect(() => {
    if (child)
      return setReferenceElement(childRef.current), () => setReferenceElement(null);
  }, [child]), !child) return /* @__PURE__ */ jsx(Fragment, {});
  if (disabled) return child;
  const tooltip = /* @__PURE__ */ jsx(Root$a, { "data-ui": "Tooltip", ...restProps, ref: setFloating, style: {
    ...floatingStyles,
    maxWidth: tooltipMaxWidth > 0 ? `${tooltipMaxWidth}px` : void 0
  }, zOffset, children: /* @__PURE__ */ jsx(TooltipCard, { ...restProps, animate, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, originX, originY, padding, placement, radius, ref: setFloating, scheme, shadow, children: content }) }), children = showTooltip && (portalProp ? /* @__PURE__ */ jsx(Portal, { __unstable_name: typeof portalProp == "string" ? portalProp : void 0, children: tooltip }) : tooltip);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    animate ? /* @__PURE__ */ jsx(AnimatePresence, { children }) : children,
    child
  ] });
});
Tooltip.displayName = "ForwardRef(Tooltip)";
function useCloseOnMouseLeave(t0) {
  const $ = c(7), {
    handleIsOpenChange,
    referenceElement,
    showTooltip
  } = t0;
  let t1;
  $[0] !== referenceElement || $[1] !== handleIsOpenChange ? (t1 = (target, teardown) => {
    referenceElement && (referenceElement === target || target instanceof Node && referenceElement.contains(target) || (handleIsOpenChange(!1), teardown()));
  }, $[0] = referenceElement, $[1] = handleIsOpenChange, $[2] = t1) : t1 = $[2];
  const onMouseMove = useEffectEvent(t1);
  let t2, t3;
  $[3] !== showTooltip || $[4] !== onMouseMove ? (t2 = () => {
    if (!showTooltip)
      return;
    const handleMouseMove = (event) => {
      onMouseMove(event.target, () => window.removeEventListener("mousemove", handleMouseMove));
    };
    return window.addEventListener("mousemove", handleMouseMove), () => window.removeEventListener("mousemove", handleMouseMove);
  }, t3 = [onMouseMove, showTooltip], $[3] = showTooltip, $[4] = onMouseMove, $[5] = t2, $[6] = t3) : (t2 = $[5], t3 = $[6]), useEffect(t2, t3);
}
const Root$9 = styled.div`
  line-height: 0;
`, ListBox = styled(Box)`
  & > ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
`, rotate = keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function AutocompleteOption(props) {
  const $ = c(11), {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  let t0;
  $[0] !== onSelect || $[1] !== value ? (t0 = () => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, $[0] = onSelect, $[1] = value, $[2] = t0) : t0 = $[2];
  const handleClick = t0;
  let t1;
  $[3] !== handleClick ? (t1 = (event) => {
    event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
  }, $[3] = handleClick, $[4] = t1) : t1 = $[4];
  const handleKeyDown = t1;
  let t2;
  return $[5] !== selected || $[6] !== id || $[7] !== handleClick || $[8] !== handleKeyDown || $[9] !== children ? (t2 = /* @__PURE__ */ jsx("li", { "aria-selected": selected, "data-ui": "AutocompleteOption", id, role: "option", onClick: handleClick, onKeyDown: handleKeyDown, children }), $[5] = selected, $[6] = id, $[7] = handleClick, $[8] = handleKeyDown, $[9] = children, $[10] = t2) : t2 = $[10], t2;
}
function autocompleteReducer(state, msg2) {
  return msg2.type === "input/change" ? {
    ...state,
    activeValue: null,
    focused: !0,
    query: msg2.query
  } : msg2.type === "input/focus" ? {
    ...state,
    focused: !0
  } : msg2.type === "root/blur" ? {
    ...state,
    focused: !1,
    query: null
  } : msg2.type === "root/clear" ? {
    ...state,
    activeValue: null,
    query: null,
    value: null
  } : msg2.type === "root/escape" ? {
    ...state,
    focused: !1,
    query: null
  } : msg2.type === "root/open" ? {
    ...state,
    query: state.query || msg2.query
  } : msg2.type === "root/setActiveValue" ? {
    ...state,
    activeValue: msg2.value,
    listFocused: msg2.listFocused || state.listFocused
  } : msg2.type === "root/setListFocused" ? {
    ...state,
    listFocused: msg2.listFocused
  } : msg2.type === "value/change" ? {
    ...state,
    activeValue: msg2.value,
    query: null,
    value: msg2.value
  } : state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"], AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start", AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"], DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value, DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1, InnerAutocomplete = forwardRef(function(props, forwardedRef) {
  const {
    border: border2 = !0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props, [state, dispatch] = useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: !1,
    listFocused: !1,
    query: null,
    value: valueProp || null
  }), {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state, defaultRenderOption = useCallback(({
    value: value_0
  }) => /* @__PURE__ */ jsx(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsx(Text, { size: fontSize2, textOverflow: "ellipsis", children: value_0 }) }), [fontSize2, paddingProp]), renderOption = typeof renderOptionProp == "function" ? renderOptionProp : defaultRenderOption, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = useRef(null), resultsPopoverElementRef = useRef(null), inputElementRef = useRef(null), listBoxElementRef = useRef(null), listFocusedRef = useRef(!1), valueRef = useRef(value), valuePropRef = useRef(valueProp), popoverMouseWithinRef = useRef(!1);
  useImperativeHandle(forwardedRef, () => inputElementRef.current);
  const listBoxId = `${id}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = useArrayProp(paddingProp), currentOption = useMemo(() => value !== null ? options.find((o) => o.value === value) : void 0, [options, value]), filteredOptions = useMemo(() => options.filter((option) => query ? filterOption(query, option) : !0), [filterOption, options, query]), filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null, handleRootBlur = useCallback((event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current)
        return;
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = !1;
      if (document.activeElement) {
        for (const e of elements)
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = !0;
            break;
          }
      }
      focusInside === !1 && (dispatch({
        type: "root/blur"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]), handleRootFocus = useCallback((event_0) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event_0.target instanceof HTMLElement ? event_0.target : null, listFocused_0 = listBoxElement?.contains(focusedElement) || !1;
    listFocused_0 !== listFocusedRef.current && (listFocusedRef.current = listFocused_0, dispatch({
      type: "root/setListFocused",
      listFocused: listFocused_0
    }));
  }, []), handleOptionSelect = useCallback((v) => {
    dispatch({
      type: "value/change",
      value: v
    }), popoverMouseWithinRef.current = !1, onSelect && onSelect(v), valueRef.current = v, onChange && onChange(v), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, [onChange, onSelect, onQueryChange]), handleRootKeyDown = useCallback((event_1) => {
    if (event_1.key === "ArrowDown") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption = filteredOptions.find((o_0) => o_0.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      nextActiveOption && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "ArrowUp") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption_0 = filteredOptions.find((o_1) => o_1.value === activeValue), activeIndex_0 = activeOption_0 ? filteredOptions.indexOf(activeOption_0) : -1, nextActiveOption_0 = filteredOptions[activeIndex_0 === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex_0 - 1) % filteredOptionsLen];
      nextActiveOption_0 && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption_0.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "Escape") {
      dispatch({
        type: "root/escape"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
      return;
    }
    const target = event_1.target, listEl = listBoxElementRef.current;
    if ((listEl === target || listEl?.contains(target)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event_1.key)) {
      inputElementRef.current?.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]), handleInputChange = useCallback((event_2) => {
    const nextQuery = event_2.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    }), onQueryChange && onQueryChange(nextQuery);
  }, [onQueryChange]), dispatchOpen = useCallback(() => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, [currentOption, renderValue, value]), handleInputFocus = useCallback((event_3) => {
    focused || (dispatch({
      type: "input/focus"
    }), onFocus && onFocus(event_3), openOnFocus && dispatchOpen());
  }, [focused, onFocus, openOnFocus, dispatchOpen]), handlePopoverMouseEnter = useCallback(() => {
    popoverMouseWithinRef.current = !0;
  }, []), handlePopoverMouseLeave = useCallback(() => {
    popoverMouseWithinRef.current = !1;
  }, []), handleClearButtonClick = useCallback(() => {
    dispatch({
      type: "root/clear"
    }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, [onChange, onQueryChange]), handleClearButtonFocus = useCallback(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({
        type: "value/change",
        value: valueProp
      }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({
      type: "value/change",
      value: valueProp || null
    }));
  }, [valueProp]), useEffect(() => {
    !focused && valueRef.current && dispatch({
      type: "root/setActiveValue",
      value: valueRef.current
    });
  }, [focused]), useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption_1 = filteredOptions.find((o_2) => o_2.value === activeValue);
    if (activeOption_1) {
      const activeIndex_1 = filteredOptions.indexOf(activeOption_1), activeItemElement = listElement.childNodes[activeIndex_1];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const clearButton = useMemo(() => {
    if (!loading && !disabled && value)
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
  }, [disabled, handleClearButtonFocus, loading, value]), openButtonBoxPadding = useMemo(() => padding.map((v_0) => v_0 === 0 ? 0 : v_0 === 1 || v_0 === 2 ? 1 : v_0 - 2), [padding]), openButtonPadding = useMemo(() => padding.map((v_1) => Math.max(v_1 - 1, 0)), [padding]), openButtonProps = useMemo(() => typeof openButton == "object" ? openButton : EMPTY_RECORD, [openButton]), handleOpenClick = useCallback((event_4) => {
    dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event_4), _raf(() => inputElementRef.current?.focus());
  }, [openButtonProps, dispatchOpen]), openButtonNode = useMemo(() => !disabled && !readOnly && openButton ? /* @__PURE__ */ jsx(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: /* @__PURE__ */ jsx(Button, { "aria-label": "Open", disabled: expanded, fontSize: fontSize2, icon: ChevronDownIcon, mode: "bleed", padding: openButtonPadding, ...openButtonProps, onClick: handleOpenClick }) }) : void 0, [disabled, expanded, fontSize2, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]), inputValue = useMemo(() => query === null ? value !== null ? renderValue(value, currentOption) : "" : query, [currentOption, query, renderValue, value]), input = /* @__PURE__ */ jsx(TextInput, { ...restProps, "aria-activedescendant": activeItemId, "aria-autocomplete": "list", "aria-expanded": expanded, "aria-owns": listBoxId, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", border: border2, clearButton, customValidity, disabled, fontSize: fontSize2, icon, iconRight: loading && AnimatedSpinnerIcon, id, inputMode: "search", onChange: handleInputChange, onClear: handleClearButtonClick, onFocus: handleInputFocus, padding, prefix, radius, readOnly, ref: inputElementRef, role: "combobox", spellCheck: !1, suffix: suffix || openButtonNode, value: inputValue }), handleListBoxKeyDown = useCallback((event_5) => {
    event_5.key === "Tab" && listFocused && inputElementRef.current?.focus();
  }, [listFocused]), content = useMemo(() => filteredOptions.length === 0 ? null : /* @__PURE__ */ jsx(ListBox, { "data-ui": "AutoComplete__results", onKeyDown: handleListBoxKeyDown, padding: 1, ...listBox, tabIndex: -1, children: /* @__PURE__ */ jsx(Stack, { as: "ul", "aria-multiselectable": !1, "data-ui": "AutoComplete__resultsList", id: listBoxId, ref: listBoxElementRef, role: "listbox", space: 1, children: filteredOptions.map((option_0) => {
    const active = activeValue !== null ? option_0.value === activeValue : currentOption === option_0;
    return /* @__PURE__ */ jsx(AutocompleteOption, { id: `${id}-option-${option_0.value}`, onSelect: handleOptionSelect, selected: active, value: option_0.value, children: cloneElement(renderOption(option_0), {
      disabled: loading,
      selected: active,
      tabIndex: listFocused && active ? 0 : -1
    }) }, option_0.value);
  }) }) }), [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]), results = useMemo(() => renderPopover ? renderPopover({
    content,
    hidden: !expanded,
    inputElement: inputElementRef.current,
    onMouseEnter: handlePopoverMouseEnter,
    onMouseLeave: handlePopoverMouseLeave
  }, resultsPopoverElementRef) : filteredOptionsLen === 0 ? null : /* @__PURE__ */ jsx(Popover, { arrow: !1, constrainSize: !0, content, fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS, matchReferenceWidth: !0, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, open: expanded, overflow: "auto", placement: AUTOCOMPLETE_POPOVER_PLACEMENT, portal: !0, radius, ref: resultsPopoverElementRef, referenceElement: inputElementRef.current, ...popover }), [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return /* @__PURE__ */ jsxs(Root$9, { "data-ui": "Autocomplete", onBlur: handleRootBlur, onFocus: handleRootFocus, onKeyDown: handleRootKeyDown, ref: rootElementRef, children: [
    input,
    results
  ] });
});
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
const Autocomplete = InnerAutocomplete, Root$8 = styled.ol`
  margin: 0;
  padding: 0;
  display: flex;
  list-style: none;
  align-items: center;
  white-space: nowrap;
  line-height: 0;
`, ExpandButton = styled(Button)`
  appearance: none;
  margin: -4px;
`, Breadcrumbs = forwardRef(function(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props, space = useArrayProp(spaceRaw), [open, setOpen] = useState(!1), expandElementRef = useRef(null), popoverElementRef = useRef(null), collapse = useCallback(() => setOpen(!1), []), expand = useCallback(() => setOpen(!0), []);
  useClickOutsideEvent(collapse, () => [expandElementRef.current, popoverElementRef.current]);
  const rawItems = useMemo(() => Children.toArray(children).filter(isValidElement), [children]), items = useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), /* @__PURE__ */ jsx(Popover, { constrainSize: !0, content: /* @__PURE__ */ jsx(Stack, { as: "ol", overflow: "auto", padding: space, space, children: rawItems.slice(beforeLength - 1, len - afterLength) }), open, placement: "top", portal: !0, ref: popoverElementRef, children: /* @__PURE__ */ jsx(ExpandButton, { fontSize: 1, mode: "bleed", onClick: open ? collapse : expand, padding: 1, ref: expandElementRef, selected: open, text: "\u2026" }) }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */ jsx(Root$8, { "data-ui": "Breadcrumbs", ...restProps, ref, children: items.map((item, itemIndex) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
    itemIndex > 0 && /* @__PURE__ */ jsx(Box, { "aria-hidden": !0, as: "li", paddingX: space, children: separator || /* @__PURE__ */ jsx(Text, { muted: !0, children: "/" }) }),
    /* @__PURE__ */ jsx(Box, { as: "li", children: item })
  ] }, itemIndex)) });
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function dialogStyle({
  theme
}) {
  const {
    color
  } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$position, (position) => ({
    "&&": {
      position
    }
  }));
}
function animationDialogStyle(props) {
  return props.$animate ? css`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : css``;
}
const DialogContext = createGlobalScopedContext("@sanity/ui/context/dialog", {
  version: 0
});
function useDialog() {
  return useContext(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? !0 : containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
const Root$7 = styled(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle), DialogContainer = styled(Container)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  height: 100%;
  flex-direction: column;
  align-items: center;
  justify-content: center;
`, DialogCardRoot = styled(Card)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  min-height: 0;
  max-height: 100%;
  overflow: hidden;
  overflow: clip;
`, DialogLayout = styled(Flex)`
  flex: 1;
  min-height: 0;
  width: 100%;
`, DialogHeader = styled(Box)`
  position: relative;
  z-index: 2;
`, DialogContent = styled(Box)`
  position: relative;
  z-index: 1;
  overflow: auto;
  outline: none;
`, DialogFooter = styled(Box)`
  position: relative;
  z-index: 3;
`, DialogCard = forwardRef(function(props, forwardedRef) {
  const $ = c(38), {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element, radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), width = useArrayProp(widthProp), ref = useRef(null), contentRef = useRef(null), layer = useLayer(), {
    isTopLayer
  } = layer, labelId = `${id}_label`, showCloseButton = !!onClose && hideCloseButton === !1, showHeader = !!header || showCloseButton;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $[0] = t0) : t0 = $[0], useImperativeHandle(forwardedRef, t0);
  let t1;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => contentRef.current, $[1] = t1) : t1 = $[1], useImperativeHandle(forwardedContentRef, t1);
  let t2, t3;
  $[2] !== autoFocus ? (t2 = () => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, t3 = [autoFocus, ref], $[2] = autoFocus, $[3] = t2, $[4] = t3) : (t2 = $[3], t3 = $[4]), useEffect(t2, t3);
  let t4;
  $[5] !== isTopLayer || $[6] !== onClose || $[7] !== boundaryElement || $[8] !== portalElement ? (t4 = (event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
  }, $[5] = isTopLayer, $[6] = onClose, $[7] = boundaryElement, $[8] = portalElement, $[9] = t4) : t4 = $[9], useGlobalKeyDown(t4);
  let t5;
  $[10] !== isTopLayer || $[11] !== onClickOutside || $[12] !== boundaryElement || $[13] !== portalElement ? (t5 = isTopLayer && onClickOutside && ((event_0) => {
    const target_0 = event_0.target;
    target_0 && !isTargetWithinScope(boundaryElement, portalElement, target_0) || onClickOutside();
  }), $[10] = isTopLayer, $[11] = onClickOutside, $[12] = boundaryElement, $[13] = portalElement, $[14] = t5) : t5 = $[14];
  let t6;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => [ref.current], $[15] = t6) : t6 = $[15], useClickOutsideEvent(t5, t6);
  let t7;
  $[16] !== showHeader || $[17] !== header || $[18] !== labelId || $[19] !== showCloseButton || $[20] !== onClose ? (t7 = showHeader && /* @__PURE__ */ jsx(DialogHeader, { children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", padding: 3, children: [
    /* @__PURE__ */ jsx(Box, { flex: 1, padding: 2, children: header && /* @__PURE__ */ jsx(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
    showCloseButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Button, { "aria-label": "Close dialog", disabled: !onClose, icon: CloseIcon, mode: "bleed", onClick: onClose, padding: 2 }) })
  ] }) }), $[16] = showHeader, $[17] = header, $[18] = labelId, $[19] = showCloseButton, $[20] = onClose, $[21] = t7) : t7 = $[21];
  let t8;
  $[22] !== children ? (t8 = /* @__PURE__ */ jsx(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }), $[22] = children, $[23] = t8) : t8 = $[23];
  let t9;
  $[24] !== footer ? (t9 = footer && /* @__PURE__ */ jsx(DialogFooter, { children: footer }), $[24] = footer, $[25] = t9) : t9 = $[25];
  let t10;
  $[26] !== t7 || $[27] !== t8 || $[28] !== t9 ? (t10 = /* @__PURE__ */ jsxs(DialogLayout, { direction: "column", children: [
    t7,
    t8,
    t9
  ] }), $[26] = t7, $[27] = t8, $[28] = t9, $[29] = t10) : t10 = $[29];
  let t11;
  $[30] !== radius || $[31] !== scheme || $[32] !== shadow || $[33] !== t10 ? (t11 = /* @__PURE__ */ jsx(DialogCardRoot, { radius, ref, scheme, shadow, children: t10 }), $[30] = radius, $[31] = scheme, $[32] = shadow, $[33] = t10, $[34] = t11) : t11 = $[34];
  let t12;
  return $[35] !== width || $[36] !== t11 ? (t12 = /* @__PURE__ */ jsx(DialogContainer, { "data-ui": "DialogCard", width, children: t11 }), $[35] = width, $[36] = t11, $[37] = t12) : t12 = $[37], t12;
});
DialogCard.displayName = "ForwardRef(DialogCard)";
const Dialog = forwardRef(function(props, ref) {
  const $ = c(60), dialog = useDialog(), {
    layer
  } = useTheme_v2();
  let t0, t1, t2, t3, t4, t5, t6, _positionProp, _zOffsetProp, portalProp, onFocus, id, contentRef, footer, header, onClickOutside, onClose, scheme, children, restProps, onActivate;
  $[0] !== props ? ({
    __unstable_autoFocus: t0,
    __unstable_hideCloseButton: t1,
    cardRadius: t2,
    cardShadow: t3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: t4,
    portal: portalProp,
    position: _positionProp,
    scheme,
    width: t5,
    zOffset: _zOffsetProp,
    animate: t6,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = t5, $[7] = t6, $[8] = _positionProp, $[9] = _zOffsetProp, $[10] = portalProp, $[11] = onFocus, $[12] = id, $[13] = contentRef, $[14] = footer, $[15] = header, $[16] = onClickOutside, $[17] = onClose, $[18] = scheme, $[19] = children, $[20] = restProps, $[21] = onActivate) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], t5 = $[6], t6 = $[7], _positionProp = $[8], _zOffsetProp = $[9], portalProp = $[10], onFocus = $[11], id = $[12], contentRef = $[13], footer = $[14], header = $[15], onClickOutside = $[16], onClose = $[17], scheme = $[18], children = $[19], restProps = $[20], onActivate = $[21]);
  const autoFocus = t0 === void 0 ? !0 : t0, hideCloseButton = t1 === void 0 ? !1 : t1, cardRadiusProp = t2 === void 0 ? 4 : t2, cardShadow = t3 === void 0 ? 3 : t3, paddingProp = t4 === void 0 ? 3 : t4, widthProp = t5 === void 0 ? 0 : t5, _animate = t6 === void 0 ? !1 : t6, positionProp = _positionProp ?? (dialog.position || "fixed"), zOffsetProp = _zOffsetProp ?? (dialog.zOffset || layer.dialog.zOffset), animate = usePrefersReducedMotion() ? !1 : _animate, portal = usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = useBoundaryElement().element, cardRadius = useArrayProp(cardRadiusProp), padding = useArrayProp(paddingProp), position = useArrayProp(positionProp), width = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), preDivRef = useRef(null), postDivRef = useRef(null), cardRef = useRef(null), focusedElementRef = useRef(null);
  let t7;
  $[22] !== onFocus ? (t7 = (event) => {
    onFocus?.(event);
    const target = event.target, cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    isHTMLElement(event.target) && (focusedElementRef.current = event.target);
  }, $[22] = onFocus, $[23] = t7) : t7 = $[23];
  const handleFocus = t7, labelId = `${id}_label`, rootClickTimeoutRef = useRef();
  let t8;
  $[24] !== boundaryElement || $[25] !== portalElement ? (t8 = () => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target_0 = focusedElementRef.current;
        if (!target_0 || !document.body.contains(target_0)) {
          const cardElement_0 = cardRef.current;
          cardElement_0 && focusFirstDescendant(cardElement_0);
          return;
        }
        target_0.focus();
      }
    }, 0);
  }, $[24] = boundaryElement, $[25] = portalElement, $[26] = t8) : t8 = $[26];
  const handleRootClick = t8;
  let t9;
  $[27] === Symbol.for("react.memo_cache_sentinel") ? (t9 = /* @__PURE__ */ jsx("div", { ref: preDivRef, tabIndex: 0 }), $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== autoFocus || $[29] !== hideCloseButton || $[30] !== contentRef || $[31] !== footer || $[32] !== header || $[33] !== id || $[34] !== onClickOutside || $[35] !== onClose || $[36] !== portalProp || $[37] !== cardRadius || $[38] !== scheme || $[39] !== cardShadow || $[40] !== width || $[41] !== children ? (t10 = /* @__PURE__ */ jsx(DialogCard, { __unstable_autoFocus: autoFocus, __unstable_hideCloseButton: hideCloseButton, contentRef, footer, header, id, onClickOutside, onClose, portal: portalProp, radius: cardRadius, ref: cardRef, scheme, shadow: cardShadow, width, children }), $[28] = autoFocus, $[29] = hideCloseButton, $[30] = contentRef, $[31] = footer, $[32] = header, $[33] = id, $[34] = onClickOutside, $[35] = onClose, $[36] = portalProp, $[37] = cardRadius, $[38] = scheme, $[39] = cardShadow, $[40] = width, $[41] = children, $[42] = t10) : t10 = $[42];
  let t11;
  $[43] === Symbol.for("react.memo_cache_sentinel") ? (t11 = /* @__PURE__ */ jsx("div", { ref: postDivRef, tabIndex: 0 }), $[43] = t11) : t11 = $[43];
  let t12;
  $[44] !== restProps || $[45] !== animate || $[46] !== padding || $[47] !== position || $[48] !== labelId || $[49] !== id || $[50] !== onActivate || $[51] !== handleRootClick || $[52] !== handleFocus || $[53] !== ref || $[54] !== zOffset || $[55] !== t10 ? (t12 = /* @__PURE__ */ jsxs(Root$7, { ...restProps, $animate: animate, $padding: padding, $position: position, "aria-labelledby": labelId, "aria-modal": !0, "data-ui": "Dialog", id, onActivate, onClick: handleRootClick, onFocus: handleFocus, ref, role: "dialog", zOffset, children: [
    t9,
    t10,
    t11
  ] }), $[44] = restProps, $[45] = animate, $[46] = padding, $[47] = position, $[48] = labelId, $[49] = id, $[50] = onActivate, $[51] = handleRootClick, $[52] = handleFocus, $[53] = ref, $[54] = zOffset, $[55] = t10, $[56] = t12) : t12 = $[56];
  let t13;
  return $[57] !== portalProp || $[58] !== t12 ? (t13 = /* @__PURE__ */ jsx(Portal, { __unstable_name: portalProp, children: t12 }), $[57] = portalProp, $[58] = t12, $[59] = t13) : t13 = $[59], t13;
});
Dialog.displayName = "ForwardRef(Dialog)";
function DialogProvider(props) {
  const $ = c(6), {
    children,
    position,
    zOffset
  } = props;
  let t0, t1;
  $[0] !== position || $[1] !== zOffset ? (t1 = {
    version: 0,
    position,
    zOffset
  }, $[0] = position, $[1] = zOffset, $[2] = t1) : t1 = $[2], t0 = t1;
  const contextValue = t0;
  let t2;
  return $[3] !== contextValue || $[4] !== children ? (t2 = /* @__PURE__ */ jsx(DialogContext.Provider, { value: contextValue, children }), $[3] = contextValue, $[4] = children, $[5] = t2) : t2 = $[5], t2;
}
DialogProvider.displayName = "DialogProvider";
const Root$6 = styled.kbd`
  font: inherit;
  padding: 1px;

  &:not([hidden]) {
    display: block;
  }
`, Key = styled(KBD)`
  &:not([hidden]) {
    display: block;
  }
`, Hotkeys = forwardRef(function(props, ref) {
  const $ = c(24);
  let t0, keys, fontSize2, padding, radius, restProps;
  $[0] !== props ? ({
    fontSize: fontSize2,
    keys,
    padding,
    radius,
    space: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = keys, $[3] = fontSize2, $[4] = padding, $[5] = radius, $[6] = restProps) : (t0 = $[1], keys = $[2], fontSize2 = $[3], padding = $[4], radius = $[5], restProps = $[6]);
  const space = useArrayProp(t0 === void 0 ? 0.5 : t0);
  if (!keys || keys.length === 0) {
    let t12;
    return $[7] === Symbol.for("react.memo_cache_sentinel") ? (t12 = /* @__PURE__ */ jsx(Fragment, {}), $[7] = t12) : t12 = $[7], t12;
  }
  let t1;
  if ($[8] !== fontSize2 || $[9] !== padding || $[10] !== radius || $[11] !== keys) {
    let t22;
    $[13] !== fontSize2 || $[14] !== padding || $[15] !== radius ? (t22 = (key2, i) => /* @__PURE__ */ jsx(Key, { fontSize: fontSize2, padding, radius, children: key2 }, i), $[13] = fontSize2, $[14] = padding, $[15] = radius, $[16] = t22) : t22 = $[16], t1 = keys.map(t22), $[8] = fontSize2, $[9] = padding, $[10] = radius, $[11] = keys, $[12] = t1;
  } else
    t1 = $[12];
  let t2;
  $[17] !== space || $[18] !== t1 ? (t2 = /* @__PURE__ */ jsx(Inline, { as: "span", space, children: t1 }), $[17] = space, $[18] = t1, $[19] = t2) : t2 = $[19];
  let t3;
  return $[20] !== restProps || $[21] !== ref || $[22] !== t2 ? (t3 = /* @__PURE__ */ jsx(Root$6, { "data-ui": "Hotkeys", ...restProps, ref, children: t2 }), $[20] = restProps, $[21] = ref, $[22] = t2, $[23] = t3) : t3 = $[23], t3;
});
Hotkeys.displayName = "ForwardRef(Hotkeys)";
const MenuContext = createGlobalScopedContext("@sanity/ui/context/menu", null);
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map = /* @__PURE__ */ new WeakMap();
  for (const el of elements)
    map.set(el, _getDOMPath(rootElement, el));
  const _sort = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH, _b = map.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef
  } = props, elementsRef = useRef([]), [activeIndex, _setActiveIndex] = useState(-1), activeIndexRef = useRef(activeIndex), activeElement = useMemo(() => elementsRef.current[activeIndex] || null, [activeIndex]), mounted = !!rootElementRef.current, setActiveIndex = useCallback((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex), activeIndexRef.current = nextActiveIndex;
  }, []), mount = useCallback((element, selected) => {
    if (!element) return () => {
    };
    if (elementsRef.current.indexOf(element) === -1 && (elementsRef.current.push(element), _sortElements(rootElementRef.current, elementsRef.current)), selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      idx > -1 && elementsRef.current.splice(idx, 1);
    };
  }, [rootElementRef, setActiveIndex]), handleKeyDown = useCallback((event) => {
    if (event.key === "Tab") {
      originElement && originElement.focus();
      return;
    }
    if (event.key === "Home") {
      event.preventDefault(), event.stopPropagation();
      const el = _getFocusableElements(elementsRef.current)[0];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_0 = _getFocusableElements(elementsRef.current), el_0 = focusableElements_0[focusableElements_0.length - 1];
      if (!el_0) return;
      const currentIndex_0 = elementsRef.current.indexOf(el_0);
      setActiveIndex(currentIndex_0);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_1 = _getFocusableElements(elementsRef.current), focusableLen = focusableElements_1.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements_1.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el_1 = focusableElements_1[focusedIndex], currentIndex_1 = elementsRef.current.indexOf(el_1);
      setActiveIndex(currentIndex_1);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_2 = _getFocusableElements(elementsRef.current), focusableLen_0 = focusableElements_2.length;
      if (focusableLen_0 === 0) return;
      const focusedElement_0 = elementsRef.current[activeIndexRef.current];
      let focusedIndex_0 = focusableElements_2.indexOf(focusedElement_0);
      focusedIndex_0 = (focusedIndex_0 + 1) % focusableLen_0;
      const el_2 = focusableElements_2[focusedIndex_0], currentIndex_2 = elementsRef.current.indexOf(el_2);
      setActiveIndex(currentIndex_2);
      return;
    }
    onKeyDown && onKeyDown(event);
  }, [onKeyDown, originElement, setActiveIndex]), handleItemMouseEnter = useCallback((event_0) => {
    const element_0 = event_0.currentTarget, currentIndex_3 = elementsRef.current.indexOf(element_0);
    setActiveIndex(currentIndex_3);
  }, [setActiveIndex]), handleItemMouseLeave = useCallback(() => {
    setActiveIndex(-2), rootElementRef.current?.focus();
  }, [rootElementRef, setActiveIndex]);
  return useEffect(() => {
    if (!mounted) return;
    const rafId = requestAnimationFrame(() => {
      if (activeIndex === -1) {
        if (shouldFocus === "first") {
          const el_3 = _getFocusableElements(elementsRef.current)[0];
          if (el_3) {
            const currentIndex_4 = elementsRef.current.indexOf(el_3);
            setActiveIndex(currentIndex_4);
          }
        }
        if (shouldFocus === "last") {
          const focusableElements_4 = _getFocusableElements(elementsRef.current), el_4 = focusableElements_4[focusableElements_4.length - 1];
          if (el_4) {
            const currentIndex_5 = elementsRef.current.indexOf(el_4);
            setActiveIndex(currentIndex_5);
          }
        }
        return;
      }
      (elementsRef.current[activeIndex] || null)?.focus();
    });
    return () => cancelAnimationFrame(rafId);
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  };
}
const Root$5 = styled(Box)`
  outline: none;
  overflow: auto;
`, Menu = forwardRef(function(props, forwardedRef) {
  const $ = c(50);
  let t0, t1, _shouldFocus, onKeyDown, originElement, registerElement, onItemSelect, onClickOutside, onEscape, onItemClick, children, restProps;
  if ($[0] !== props) {
    const {
      children: t22,
      focusFirst,
      focusLast,
      onClickOutside: t32,
      onEscape: t42,
      onItemClick: t52,
      onItemSelect: t62,
      onKeyDown: t72,
      originElement: t82,
      padding: t92,
      registerElement: t102,
      shouldFocus: t112,
      space: t122,
      ...t132
    } = props;
    children = t22, onClickOutside = t32, onEscape = t42, onItemClick = t52, onItemSelect = t62, onKeyDown = t72, originElement = t82, t0 = t92, registerElement = t102, _shouldFocus = t112, t1 = t122, restProps = t132, $[0] = props, $[1] = t0, $[2] = t1, $[3] = _shouldFocus, $[4] = onKeyDown, $[5] = originElement, $[6] = registerElement, $[7] = onItemSelect, $[8] = onClickOutside, $[9] = onEscape, $[10] = onItemClick, $[11] = children, $[12] = restProps;
  } else
    t0 = $[1], t1 = $[2], _shouldFocus = $[3], onKeyDown = $[4], originElement = $[5], registerElement = $[6], onItemSelect = $[7], onClickOutside = $[8], onEscape = $[9], onItemClick = $[10], children = $[11], restProps = $[12];
  const padding = t0 === void 0 ? 1 : t0, space = t1 === void 0 ? 1 : t1, shouldFocus = _shouldFocus ?? (props.focusFirst && "first" || props.focusLast && "last" || null), ref = useRef(null);
  let t2;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => ref.current, $[13] = t2) : t2 = $[13], useImperativeHandle(forwardedRef, t2);
  const {
    isTopLayer
  } = useLayer();
  let t3;
  $[14] !== onKeyDown || $[15] !== originElement || $[16] !== shouldFocus ? (t3 = {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef: ref
  }, $[14] = onKeyDown, $[15] = originElement, $[16] = shouldFocus, $[17] = t3) : t3 = $[17];
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  } = useMenuController(t3), unregisterElementRef = useRef(null);
  let t4;
  $[18] !== registerElement ? (t4 = (el) => {
    unregisterElementRef.current && (unregisterElementRef.current(), unregisterElementRef.current = null), ref.current = el, ref.current && registerElement && (unregisterElementRef.current = registerElement(ref.current));
  }, $[18] = registerElement, $[19] = t4) : t4 = $[19];
  const handleRefChange = t4;
  let t5, t6;
  $[20] !== onItemSelect || $[21] !== activeIndex ? (t5 = () => {
    onItemSelect && onItemSelect(activeIndex);
  }, t6 = [activeIndex, onItemSelect], $[20] = onItemSelect, $[21] = activeIndex, $[22] = t5, $[23] = t6) : (t5 = $[22], t6 = $[23]), useEffect(t5, t6);
  let t7;
  $[24] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => [ref.current], $[24] = t7) : t7 = $[24], useClickOutsideEvent(isTopLayer && onClickOutside, t7);
  let t8;
  $[25] !== isTopLayer || $[26] !== onEscape ? (t8 = (event) => {
    isTopLayer && event.key === "Escape" && (event.stopPropagation(), onEscape && onEscape());
  }, $[25] = isTopLayer, $[26] = onEscape, $[27] = t8) : t8 = $[27], useGlobalKeyDown(t8);
  let t9, t10;
  $[28] !== activeElement || $[29] !== activeIndex || $[30] !== mount || $[31] !== onClickOutside || $[32] !== onEscape || $[33] !== onItemClick || $[34] !== handleItemMouseEnter || $[35] !== handleItemMouseLeave || $[36] !== registerElement ? (t10 = {
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }, $[28] = activeElement, $[29] = activeIndex, $[30] = mount, $[31] = onClickOutside, $[32] = onEscape, $[33] = onItemClick, $[34] = handleItemMouseEnter, $[35] = handleItemMouseLeave, $[36] = registerElement, $[37] = t10) : t10 = $[37], t9 = t10;
  const value = t9;
  let t11;
  $[38] !== space || $[39] !== children ? (t11 = /* @__PURE__ */ jsx(Stack, { space, children }), $[38] = space, $[39] = children, $[40] = t11) : t11 = $[40];
  let t12;
  $[41] !== restProps || $[42] !== handleKeyDown || $[43] !== padding || $[44] !== handleRefChange || $[45] !== t11 ? (t12 = /* @__PURE__ */ jsx(Root$5, { "data-ui": "Menu", ...restProps, onKeyDown: handleKeyDown, padding, ref: handleRefChange, role: "menu", tabIndex: -1, children: t11 }), $[41] = restProps, $[42] = handleKeyDown, $[43] = padding, $[44] = handleRefChange, $[45] = t11, $[46] = t12) : t12 = $[46];
  let t13;
  return $[47] !== value || $[48] !== t12 ? (t13 = /* @__PURE__ */ jsx(MenuContext.Provider, { value, children: t12 }), $[47] = value, $[48] = t12, $[49] = t13) : t13 = $[49], t13;
});
Menu.displayName = "ForwardRef(Menu)";
const MenuButton = forwardRef(function(props, forwardedRef) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = !1,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = !0,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, [open, setOpen] = useState(!1), [shouldFocus, setShouldFocus] = useState(null), [buttonElement, setButtonElement] = useState(null), [menuElements, setChildMenuElements] = useState([]), openRef = useRef(open);
  useEffect(() => {
    onOpen && open && !openRef.current && onOpen();
  }, [onOpen, open]), useEffect(() => {
    onClose && !open && openRef.current && onClose();
  }, [onClose, open]), useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = useCallback(() => {
    setOpen((v) => !v), setShouldFocus(null);
  }, []), handleMouseDown = useCallback((event) => {
    open && event.preventDefault();
  }, [open]), handleButtonKeyDown = useCallback((event_0) => {
    if (event_0.key === "ArrowDown" || event_0.key === "Enter" || event_0.key === " ") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("first");
      return;
    }
    if (event_0.key === "ArrowUp") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("last");
      return;
    }
  }, []), handleMenuClickOutside = useCallback((event_1) => {
    const target = event_1.target;
    if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
      for (const el of menuElements)
        if (target === el || el.contains(target))
          return;
      setOpen(!1);
    }
  }, [buttonElement, menuElements]), handleMenuEscape = useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), handleBlur = useCallback((event_2) => {
    const target_0 = event_2.relatedTarget;
    if (target_0 instanceof Node) {
      for (const el_0 of menuElements)
        if (el_0 === target_0 || el_0.contains(target_0))
          return;
      setOpen(!1);
    }
  }, [menuElements]), handleItemClick = useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), registerElement = useCallback((el_1) => (setChildMenuElements((els) => els.concat([el_1])), () => setChildMenuElements((els_0) => els_0.filter((_el) => _el !== el_1))), []), menuProps = useMemo(() => ({
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id, handleBlur, registerElement, shouldFocus]), menu = menuProp && cloneElement(menuProp, menuProps), ref = useRef(null), button = useMemo(() => buttonProp && cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": !0,
    "aria-expanded": open,
    ref,
    selected: buttonProp.props.selected ?? open
  }), [buttonProp, handleButtonClick, handleButtonKeyDown, handleMouseDown, id, open]);
  useImperativeHandle(forwardedRef, () => ref.current), useEffect(() => {
    if (button)
      return setButtonElement(ref.current), () => setButtonElement(null);
  }, [button]);
  const popoverProps = useMemo(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...popover || {}
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return /* @__PURE__ */ jsx(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: button || /* @__PURE__ */ jsx(Fragment, {}) });
});
MenuButton.displayName = "ForwardRef(MenuButton)";
const MenuDivider = styled.hr`
  height: 1px;
  border: 0;
  background: var(--card-hairline-soft-color);
  margin: 0;
`;
MenuDivider.displayName = "MenuDivider";
function selectableBaseStyle() {
  return css`
    background-color: inherit;
    color: inherit;

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function selectableColorStyle(props) {
  const {
    $tone
  } = props, {
    color,
    style
  } = getTheme_v2(props.theme), tone = color.selectable[$tone];
  return css`
    ${_cardColorStyle(color, tone.enabled)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);
    outline: none;

    /* &:is(button) */
    &[data-as='button'] {
      &:disabled {
        ${_cardColorStyle(color, tone.disabled)}
      }

      &:not(:disabled) {
        &[aria-pressed='true'] {
          ${_cardColorStyle(color, tone.pressed)}
        }

        &[data-selected],
        &[aria-selected='true'] > & {
          ${_cardColorStyle(color, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, tone.hovered)}
            }

            &:active {
              ${_cardColorStyle(color, tone.pressed)}
            }
          }
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      &[data-disabled] {
        ${_cardColorStyle(color, tone.disabled)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color, tone.pressed)}
        }

        &[data-selected] {
          ${_cardColorStyle(color, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color, tone.hovered)}
            }
            &:active {
              ${_cardColorStyle(color, tone.pressed)}
            }
          }
        }
      }
    }

    ${style?.card?.root}
  `;
}
const Selectable = styled(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
Selectable.displayName = "Selectable";
function useMenu() {
  const value = useContext(MenuContext);
  if (!value)
    throw new Error("useMenu(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useMenu(): the context value is not compatible");
  return value;
}
function MenuGroup(props) {
  const $ = c(77);
  let t0, t1, t2, t3, t4, t5, onClick, children, IconComponent, text, restProps, popover;
  $[0] !== props ? ({
    as: t0,
    children,
    fontSize: t1,
    icon: IconComponent,
    onClick,
    padding: t2,
    popover,
    radius: t3,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = t5, $[7] = onClick, $[8] = children, $[9] = IconComponent, $[10] = text, $[11] = restProps, $[12] = popover) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], t5 = $[6], onClick = $[7], children = $[8], IconComponent = $[9], text = $[10], restProps = $[11], popover = $[12]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t2 === void 0 ? 3 : t2, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, menu = useMenu(), {
    scheme
  } = useRootTheme(), {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    registerElement
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onMouseEnter, [rootElement, setRootElement] = useState(null), [open, setOpen] = useState(!1), [shouldFocus, setShouldFocus] = useState(null), active = !!activeElement && activeElement === rootElement, [withinMenu, setWithinMenu] = useState(!1);
  let t6;
  $[13] !== onItemMouseEnter ? (t6 = (event) => {
    setWithinMenu(!1), onItemMouseEnter(event), setOpen(!0);
  }, $[13] = onItemMouseEnter, $[14] = t6) : t6 = $[14];
  const handleMouseEnter = t6;
  let t7;
  $[15] !== rootElement ? (t7 = (event_0) => {
    event_0.key === "ArrowLeft" && (event_0.stopPropagation(), setOpen(!1), requestAnimationFrame(() => {
      rootElement?.focus();
    }));
  }, $[15] = rootElement, $[16] = t7) : t7 = $[16];
  const handleMenuKeyDown = t7;
  let t8;
  $[17] !== onClick ? (t8 = (event_1) => {
    onClick?.(event_1), setShouldFocus("first"), setOpen(!0);
  }, $[17] = onClick, $[18] = t8) : t8 = $[18];
  const handleClick = t8;
  let t9;
  $[19] !== onItemClick ? (t9 = () => {
    setOpen(!1), onItemClick?.();
  }, $[19] = onItemClick, $[20] = t9) : t9 = $[20];
  const handleChildItemClick = t9;
  let t10;
  $[21] === Symbol.for("react.memo_cache_sentinel") ? (t10 = () => setWithinMenu(!0), $[21] = t10) : t10 = $[21];
  const handleMenuMouseEnter = t10;
  let t11, t12;
  $[22] !== mount || $[23] !== rootElement ? (t11 = () => mount(rootElement), t12 = [mount, rootElement], $[22] = mount, $[23] = rootElement, $[24] = t11, $[25] = t12) : (t11 = $[24], t12 = $[25]), useEffect(t11, t12);
  let t13, t14;
  $[26] !== active ? (t13 = () => {
    active || setOpen(!1);
  }, t14 = [active], $[26] = active, $[27] = t13, $[28] = t14) : (t13 = $[27], t14 = $[28]), useEffect(t13, t14);
  let t15, t16;
  $[29] !== open ? (t15 = () => {
    open || setWithinMenu(!1);
  }, t16 = [open], $[29] = open, $[30] = t15, $[31] = t16) : (t15 = $[30], t16 = $[31]), useEffect(t15, t16);
  let t17, t18;
  $[32] !== shouldFocus ? (t17 = () => {
    if (!shouldFocus)
      return;
    const rafId = requestAnimationFrame(() => setShouldFocus(null));
    return () => cancelAnimationFrame(rafId);
  }, t18 = [shouldFocus], $[32] = shouldFocus, $[33] = t17, $[34] = t18) : (t17 = $[33], t18 = $[34]), useEffect(t17, t18);
  let t19;
  $[35] !== onClickOutside || $[36] !== onEscape || $[37] !== handleChildItemClick || $[38] !== handleMenuKeyDown || $[39] !== registerElement || $[40] !== shouldFocus || $[41] !== children ? (t19 = /* @__PURE__ */ jsx(Menu, { onClickOutside, onEscape, onItemClick: handleChildItemClick, onKeyDown: handleMenuKeyDown, onMouseEnter: handleMenuMouseEnter, registerElement, shouldFocus, children }), $[35] = onClickOutside, $[36] = onEscape, $[37] = handleChildItemClick, $[38] = handleMenuKeyDown, $[39] = registerElement, $[40] = shouldFocus, $[41] = children, $[42] = t19) : t19 = $[42];
  const childMenu = t19;
  let t20;
  $[43] === Symbol.for("react.memo_cache_sentinel") ? (t20 = (event_2) => {
    const target = event_2.currentTarget;
    if (document.activeElement === target && event_2.key === "ArrowRight") {
      setShouldFocus("first"), setOpen(!0), setWithinMenu(!0);
      return;
    }
  }, $[43] = t20) : t20 = $[43];
  const handleKeyDown = t20, t21 = as === "button" ? withinMenu : void 0, t22 = as !== "button" ? withinMenu : void 0, t23 = !withinMenu && active ? "" : void 0, t24 = useArrayProp(radius), t25 = as === "button" ? "button" : void 0;
  let t26;
  $[44] !== IconComponent || $[45] !== fontSize2 ? (t26 = IconComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
    isValidElement(IconComponent) && IconComponent,
    isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
  ] }), $[44] = IconComponent, $[45] = fontSize2, $[46] = t26) : t26 = $[46];
  let t27;
  $[47] !== fontSize2 || $[48] !== text ? (t27 = /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }), $[47] = fontSize2, $[48] = text, $[49] = t27) : t27 = $[49];
  let t28;
  $[50] === Symbol.for("react.memo_cache_sentinel") ? (t28 = /* @__PURE__ */ jsx(ChevronRightIcon, {}), $[50] = t28) : t28 = $[50];
  let t29;
  $[51] !== fontSize2 ? (t29 = /* @__PURE__ */ jsx(Text, { size: fontSize2, children: t28 }), $[51] = fontSize2, $[52] = t29) : t29 = $[52];
  let t30;
  $[53] !== space || $[54] !== padding || $[55] !== t26 || $[56] !== t27 || $[57] !== t29 ? (t30 = /* @__PURE__ */ jsxs(Flex, { gap: space, padding, children: [
    t26,
    t27,
    t29
  ] }), $[53] = space, $[54] = padding, $[55] = t26, $[56] = t27, $[57] = t29, $[58] = t30) : t30 = $[58];
  let t31;
  $[59] !== as || $[60] !== restProps || $[61] !== t21 || $[62] !== t22 || $[63] !== t23 || $[64] !== t24 || $[65] !== tone || $[66] !== scheme || $[67] !== handleClick || $[68] !== handleMouseEnter || $[69] !== t25 || $[70] !== t30 ? (t31 = /* @__PURE__ */ jsx(Selectable, { "data-as": as, "data-ui": "MenuGroup", forwardedAs: as, ...restProps, "aria-pressed": t21, "data-pressed": t22, "data-selected": t23, $radius: t24, $tone: tone, $scheme: scheme, onClick: handleClick, onKeyDown: handleKeyDown, onMouseEnter: handleMouseEnter, ref: setRootElement, tabIndex: -1, type: t25, children: t30 }), $[59] = as, $[60] = restProps, $[61] = t21, $[62] = t22, $[63] = t23, $[64] = t24, $[65] = tone, $[66] = scheme, $[67] = handleClick, $[68] = handleMouseEnter, $[69] = t25, $[70] = t30, $[71] = t31) : t31 = $[71];
  let t32;
  return $[72] !== popover || $[73] !== childMenu || $[74] !== open || $[75] !== t31 ? (t32 = /* @__PURE__ */ jsx(Popover, { ...popover, content: childMenu, "data-ui": "MenuGroup__popover", open, children: t31 }), $[72] = popover, $[73] = childMenu, $[74] = open, $[75] = t31, $[76] = t32) : t32 = $[76], t32;
}
MenuGroup.displayName = "MenuGroup";
const MenuItem = forwardRef(function(props, forwardedRef) {
  const $ = c(74);
  let t0, t1, t2, t3, t4, t5, selectedProp, disabled, onClick, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft, pressed, IconComponent, text, IconRightComponent, hotkeys, children, restProps;
  $[0] !== props ? ({
    as: t0,
    children,
    disabled,
    fontSize: t1,
    hotkeys,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClick,
    padding: t2,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius: t3,
    selected: selectedProp,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = t2, $[4] = t3, $[5] = t4, $[6] = t5, $[7] = selectedProp, $[8] = disabled, $[9] = onClick, $[10] = paddingX, $[11] = paddingY, $[12] = paddingTop, $[13] = paddingRight, $[14] = paddingBottom, $[15] = paddingLeft, $[16] = pressed, $[17] = IconComponent, $[18] = text, $[19] = IconRightComponent, $[20] = hotkeys, $[21] = children, $[22] = restProps) : (t0 = $[1], t1 = $[2], t2 = $[3], t3 = $[4], t4 = $[5], t5 = $[6], selectedProp = $[7], disabled = $[8], onClick = $[9], paddingX = $[10], paddingY = $[11], paddingTop = $[12], paddingRight = $[13], paddingBottom = $[14], paddingLeft = $[15], pressed = $[16], IconComponent = $[17], text = $[18], IconRightComponent = $[19], hotkeys = $[20], children = $[21], restProps = $[22]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t2 === void 0 ? 3 : t2, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, {
    scheme
  } = useRootTheme(), menu = useMenu(), {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    onItemMouseLeave: _onItemMouseLeave
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onMouseEnter, onItemMouseLeave = _onItemMouseLeave ?? menu.onMouseLeave, [rootElement, setRootElement] = useState(null), active = !!activeElement && activeElement === rootElement, ref = useRef(null);
  let t6;
  $[23] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => ref.current, $[23] = t6) : t6 = $[23], useImperativeHandle(forwardedRef, t6);
  let t7, t8;
  $[24] !== mount || $[25] !== rootElement || $[26] !== selectedProp ? (t7 = () => mount(rootElement, selectedProp), t8 = [mount, rootElement, selectedProp], $[24] = mount, $[25] = rootElement, $[26] = selectedProp, $[27] = t7, $[28] = t8) : (t7 = $[27], t8 = $[28]), useEffect(t7, t8);
  let t9;
  $[29] !== disabled || $[30] !== onClick || $[31] !== onItemClick ? (t9 = (event) => {
    disabled || (onClick && onClick(event), onItemClick && onItemClick());
  }, $[29] = disabled, $[30] = onClick, $[31] = onItemClick, $[32] = t9) : t9 = $[32];
  const handleClick = t9;
  let t10, t11;
  $[33] !== padding || $[34] !== paddingX || $[35] !== paddingY || $[36] !== paddingTop || $[37] !== paddingRight || $[38] !== paddingBottom || $[39] !== paddingLeft ? (t11 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }, $[33] = padding, $[34] = paddingX, $[35] = paddingY, $[36] = paddingTop, $[37] = paddingRight, $[38] = paddingBottom, $[39] = paddingLeft, $[40] = t11) : t11 = $[40], t10 = t11;
  const paddingProps = t10, t12 = useArrayProp(fontSize2);
  let t13;
  $[41] !== t12 ? (t13 = t12.map(_temp$1), $[41] = t12, $[42] = t13) : t13 = $[42];
  const hotkeysFontSize = t13;
  let t14;
  $[43] === Symbol.for("react.memo_cache_sentinel") ? (t14 = (el) => {
    ref.current = el, setRootElement(el);
  }, $[43] = t14) : t14 = $[43];
  const setRef = t14, t15 = as === "button" && pressed, t16 = as !== "button" && pressed ? "" : void 0, t17 = active ? "" : void 0, t18 = disabled ? "" : void 0, t19 = useArrayProp(radius), t20 = useArrayProp(0), t21 = disabled ? "default" : tone, t22 = as === "button" ? "button" : void 0;
  let t23;
  $[44] !== IconComponent || $[45] !== text || $[46] !== IconRightComponent || $[47] !== fontSize2 || $[48] !== hotkeys || $[49] !== hotkeysFontSize || $[50] !== space || $[51] !== paddingProps ? (t23 = (IconComponent || text || IconRightComponent) && /* @__PURE__ */ jsxs(Flex, { as: "span", gap: space, align: "center", ...paddingProps, children: [
    IconComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
      isValidElement(IconComponent) && IconComponent,
      isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
    ] }),
    text && /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
    hotkeys && /* @__PURE__ */ jsx(Hotkeys, { fontSize: hotkeysFontSize, keys: hotkeys, style: {
      marginTop: -4,
      marginBottom: -4
    } }),
    IconRightComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
      isValidElement(IconRightComponent) && IconRightComponent,
      isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
    ] })
  ] }), $[44] = IconComponent, $[45] = text, $[46] = IconRightComponent, $[47] = fontSize2, $[48] = hotkeys, $[49] = hotkeysFontSize, $[50] = space, $[51] = paddingProps, $[52] = t23) : t23 = $[52];
  let t24;
  $[53] !== children || $[54] !== paddingProps ? (t24 = children && /* @__PURE__ */ jsx(Box, { as: "span", ...paddingProps, children }), $[53] = children, $[54] = paddingProps, $[55] = t24) : t24 = $[55];
  let t25;
  return $[56] !== restProps || $[57] !== t15 || $[58] !== t16 || $[59] !== t17 || $[60] !== t18 || $[61] !== as || $[62] !== t19 || $[63] !== t20 || $[64] !== t21 || $[65] !== scheme || $[66] !== disabled || $[67] !== handleClick || $[68] !== onItemMouseEnter || $[69] !== onItemMouseLeave || $[70] !== t22 || $[71] !== t23 || $[72] !== t24 ? (t25 = /* @__PURE__ */ jsxs(Selectable, { "data-ui": "MenuItem", ...restProps, "aria-pressed": t15, "data-pressed": t16, "data-selected": t17, "data-disabled": t18, forwardedAs: as, $radius: t19, $padding: t20, $tone: t21, $scheme: scheme, disabled, onClick: handleClick, onMouseEnter: onItemMouseEnter, onMouseLeave: onItemMouseLeave, ref: setRef, role: "menuitem", tabIndex: -1, type: t22, children: [
    t23,
    t24
  ] }), $[56] = restProps, $[57] = t15, $[58] = t16, $[59] = t17, $[60] = t18, $[61] = as, $[62] = t19, $[63] = t20, $[64] = t21, $[65] = scheme, $[66] = disabled, $[67] = handleClick, $[68] = onItemMouseEnter, $[69] = onItemMouseLeave, $[70] = t22, $[71] = t23, $[72] = t24, $[73] = t25) : t25 = $[73], t25;
});
MenuItem.displayName = "ForwardRef(MenuItem)";
function _temp$1(s) {
  return s - 1;
}
const keyframe = keyframes`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`, animation = css`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`, skeletonStyle = css`
  opacity: ${({
  $visible
}) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({
  $animated
}) => $animated ? animation : css`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`, Root$4 = styled(Box)(responsiveRadiusStyle, skeletonStyle), Skeleton = forwardRef(function(props, ref) {
  const $ = c(14);
  let t0, delay, radius, restProps;
  $[0] !== props ? ({
    animated: t0,
    delay,
    radius,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = delay, $[3] = radius, $[4] = restProps) : (t0 = $[1], delay = $[2], radius = $[3], restProps = $[4]);
  const animated = t0 === void 0 ? !1 : t0, [visible, setVisible] = useState(!delay);
  let t1, t2;
  $[5] !== delay ? (t1 = () => {
    if (!delay)
      return setVisible(!0);
    const timeout = setTimeout(() => {
      setVisible(!0);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, t2 = [delay], $[5] = delay, $[6] = t1, $[7] = t2) : (t1 = $[6], t2 = $[7]), useEffect(t1, t2);
  const t3 = useArrayProp(radius);
  let t4;
  return $[8] !== restProps || $[9] !== animated || $[10] !== t3 || $[11] !== visible || $[12] !== ref ? (t4 = /* @__PURE__ */ jsx(Root$4, { ...restProps, $animated: animated, $radius: t3, $visible: visible, ref }), $[8] = restProps, $[9] = animated, $[10] = t3, $[11] = visible, $[12] = ref, $[13] = t4) : t4 = $[13], t4;
});
Skeleton.displayName = "ForwardRef(Skeleton)";
const Root$3 = styled(Skeleton)((props) => {
  const {
    $size,
    $style
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = fontStyle.sizes[sizeIndex];
    return {
      height: fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight
    };
  });
}), TextSkeleton = forwardRef(function(props, ref) {
  const $ = c(7);
  let t0, restProps;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps) : (t0 = $[1], restProps = $[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== restProps || $[4] !== $size || $[5] !== ref ? (t1 = /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "text" }), $[3] = restProps, $[4] = $size, $[5] = ref, $[6] = t1) : t1 = $[6], t1;
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
const LabelSkeleton = forwardRef(function(props, ref) {
  const $ = c(7);
  let t0, restProps;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps) : (t0 = $[1], restProps = $[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== restProps || $[4] !== $size || $[5] !== ref ? (t1 = /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "label" }), $[3] = restProps, $[4] = $size, $[5] = ref, $[6] = t1) : t1 = $[6], t1;
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
const HeadingSkeleton = forwardRef(function(props, ref) {
  const $ = c(7);
  let t0, restProps;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps) : (t0 = $[1], restProps = $[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== restProps || $[4] !== $size || $[5] !== ref ? (t1 = /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "heading" }), $[3] = restProps, $[4] = $size, $[5] = ref, $[6] = t1) : t1 = $[6], t1;
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
const CodeSkeleton = forwardRef(function(props, ref) {
  const $ = c(7);
  let t0, restProps;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps) : (t0 = $[1], restProps = $[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== restProps || $[4] !== $size || $[5] !== ref ? (t1 = /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "code" }), $[3] = restProps, $[4] = $size, $[5] = ref, $[6] = t1) : t1 = $[6], t1;
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
const CustomButton = styled(Button)`
  max-width: 100%;
`, Tab = forwardRef(function(props, forwardedRef) {
  const $ = c(30);
  let t0, t1, onFocus, focused, selected, restProps, icon, id, onClick, label;
  $[0] !== props ? ({
    icon,
    id,
    focused,
    fontSize: t0,
    label,
    onClick,
    onFocus,
    padding: t1,
    selected,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = t1, $[3] = onFocus, $[4] = focused, $[5] = selected, $[6] = restProps, $[7] = icon, $[8] = id, $[9] = onClick, $[10] = label) : (t0 = $[1], t1 = $[2], onFocus = $[3], focused = $[4], selected = $[5], restProps = $[6], icon = $[7], id = $[8], onClick = $[9], label = $[10]);
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 2 : t1, ref = useRef(null), focusedRef = useRef(!1);
  let t2;
  $[11] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => ref.current, $[11] = t2) : t2 = $[11], useImperativeHandle(forwardedRef, t2);
  let t3;
  $[12] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    focusedRef.current = !1;
  }, $[12] = t3) : t3 = $[12];
  const handleBlur = t3;
  let t4;
  $[13] !== onFocus ? (t4 = (event) => {
    focusedRef.current = !0, onFocus && onFocus(event);
  }, $[13] = onFocus, $[14] = t4) : t4 = $[14];
  const handleFocus = t4;
  let t5, t6;
  $[15] !== focused ? (t5 = () => {
    focused && !focusedRef.current && (ref.current && ref.current.focus(), focusedRef.current = !0);
  }, t6 = [focused], $[15] = focused, $[16] = t5, $[17] = t6) : (t5 = $[16], t6 = $[17]), useEffect(t5, t6);
  const t7 = selected ? "true" : "false", t8 = selected ? 0 : -1;
  let t9;
  return $[18] !== restProps || $[19] !== t7 || $[20] !== fontSize2 || $[21] !== icon || $[22] !== id || $[23] !== onClick || $[24] !== handleFocus || $[25] !== padding || $[26] !== selected || $[27] !== t8 || $[28] !== label ? (t9 = /* @__PURE__ */ jsx(CustomButton, { "data-ui": "Tab", ...restProps, "aria-selected": t7, fontSize: fontSize2, icon, id, mode: "bleed", onClick, onBlur: handleBlur, onFocus: handleFocus, padding, ref, role: "tab", selected, tabIndex: t8, text: label, type: "button" }), $[18] = restProps, $[19] = t7, $[20] = fontSize2, $[21] = icon, $[22] = id, $[23] = onClick, $[24] = handleFocus, $[25] = padding, $[26] = selected, $[27] = t8, $[28] = label, $[29] = t9) : t9 = $[29], t9;
});
Tab.displayName = "ForwardRef(Tab)";
const CustomInline = styled(Inline)`
  & > div {
    display: inline-block;
    vertical-align: middle;
    max-width: 100%;
    box-sizing: border-box;
  }
`, TabList = forwardRef(function(props, ref) {
  const $ = c(15);
  let childrenProp, restProps;
  $[0] !== props ? ({
    children: childrenProp,
    ...restProps
  } = props, $[0] = props, $[1] = childrenProp, $[2] = restProps) : (childrenProp = $[1], restProps = $[2]);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  let t0;
  if ($[3] !== childrenProp || $[4] !== focusedIndex) {
    const children = Children.toArray(childrenProp).filter(isValidElement);
    let t12;
    $[6] !== focusedIndex ? (t12 = (child, childIndex) => cloneElement(child, {
      focused: focusedIndex === childIndex,
      key: childIndex,
      onFocus: () => setFocusedIndex(childIndex)
    }), $[6] = focusedIndex, $[7] = t12) : t12 = $[7], t0 = children.map(t12), $[3] = childrenProp, $[4] = focusedIndex, $[5] = t0;
  } else
    t0 = $[5];
  const tabs = t0, numTabs = tabs.length;
  let t1;
  $[8] !== numTabs ? (t1 = (event) => {
    event.key === "ArrowLeft" && setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs), event.key === "ArrowRight" && setFocusedIndex((prevIndex_0) => (prevIndex_0 + 1) % numTabs);
  }, $[8] = numTabs, $[9] = t1) : t1 = $[9];
  const handleKeyDown = t1;
  let t2;
  return $[10] !== restProps || $[11] !== handleKeyDown || $[12] !== ref || $[13] !== tabs ? (t2 = /* @__PURE__ */ jsx(CustomInline, { "data-ui": "TabList", ...restProps, onKeyDown: handleKeyDown, ref, role: "tablist", children: tabs }), $[10] = restProps, $[11] = handleKeyDown, $[12] = ref, $[13] = tabs, $[14] = t2) : t2 = $[14], t2;
});
TabList.displayName = "ForwardRef(TabList)";
const TabPanel = forwardRef(function(props, ref) {
  const $ = c(9);
  let restProps, flex;
  $[0] !== props ? ({
    flex,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = flex) : (restProps = $[1], flex = $[2]);
  const t0 = props.tabIndex === void 0 ? 0 : props.tabIndex;
  let t1;
  return $[3] !== restProps || $[4] !== flex || $[5] !== ref || $[6] !== t0 || $[7] !== props.children ? (t1 = /* @__PURE__ */ jsx(Box, { "data-ui": "TabPanel", ...restProps, flex, ref, role: "tabpanel", tabIndex: t0, children: props.children }), $[3] = restProps, $[4] = flex, $[5] = ref, $[6] = t0, $[7] = props.children, $[8] = t1) : t1 = $[8], t1;
});
TabPanel.displayName = "ForwardRef(TabPanel)";
const TextBox = styled(Flex)`
  overflow-x: auto;
`, loadingAnimation = keyframes`
  0% {
    width: 0;
  }
  100% {
    width: 100%;
  }
`, LOADING_BAR_HEIGHT = 2;
function rootStyles(props) {
  const {
    color
  } = getTheme_v2$1(props.theme), loadingBarColor = color.button.default[props.tone].enabled.bg;
  return props.$duration ? css`
    pointer-events: all;
    width: 100%;
    position: relative;
    overflow: hidden;
    overflow: clip;
    padding-bottom: ${LOADING_BAR_HEIGHT}px;
    &::before {
      content: '';
      position: absolute;
      bottom: 0px;
      height: ${LOADING_BAR_HEIGHT}px;
      background: ${loadingBarColor};
      animation-name: ${loadingAnimation};
      animation-duration: ${props.$duration}ms;
      animation-fill-mode: both;
    }

    & > * {
      opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
      will-change: opacity;
    }
  ` : css`
      pointer-events: all;
      & > * {
        opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
        will-change: opacity;
      }
    `;
}
const STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
}, BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
}, ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
}, Root$2 = styled(Card)(rootStyles);
function Toast(props) {
  const $ = c(30);
  let t0, status, title, description, closable, onClose, restProps, duration;
  $[0] !== props ? ({
    closable,
    description,
    duration,
    onClose,
    radius: t0,
    title,
    status,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = status, $[3] = title, $[4] = description, $[5] = closable, $[6] = onClose, $[7] = restProps, $[8] = duration) : (t0 = $[1], status = $[2], title = $[3], description = $[4], closable = $[5], onClose = $[6], restProps = $[7], duration = $[8]);
  const radius = t0 === void 0 ? 3 : t0, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status";
  let t1;
  $[9] !== title ? (t1 = title && /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: title }), $[9] = title, $[10] = t1) : t1 = $[10];
  let t2;
  $[11] !== description ? (t2 = description && /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: description }), $[11] = description, $[12] = t2) : t2 = $[12];
  let t3;
  $[13] !== t1 || $[14] !== t2 ? (t3 = /* @__PURE__ */ jsx(TextBox, { flex: 1, padding: 3, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    t1,
    t2
  ] }) }), $[13] = t1, $[14] = t2, $[15] = t3) : t3 = $[15];
  let t4;
  $[16] !== closable || $[17] !== buttonTone || $[18] !== onClose ? (t4 = closable && /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(Button, { as: "button", icon: CloseIcon, mode: "bleed", padding: 2, tone: buttonTone, onClick: onClose, style: {
    verticalAlign: "top"
  } }) }), $[16] = closable, $[17] = buttonTone, $[18] = onClose, $[19] = t4) : t4 = $[19];
  let t5;
  $[20] !== t3 || $[21] !== t4 ? (t5 = /* @__PURE__ */ jsxs(Flex, { align: "flex-start", children: [
    t3,
    t4
  ] }), $[20] = t3, $[21] = t4, $[22] = t5) : t5 = $[22];
  let t6;
  return $[23] !== role || $[24] !== restProps || $[25] !== radius || $[26] !== cardTone || $[27] !== duration || $[28] !== t5 ? (t6 = /* @__PURE__ */ jsx(Root$2, { "data-ui": "Toast", role, ...restProps, marginTop: 3, radius, shadow: 2, tone: cardTone, $duration: duration, children: t5 }), $[23] = role, $[24] = restProps, $[25] = radius, $[26] = cardTone, $[27] = duration, $[28] = t5, $[29] = t6) : t6 = $[29], t6;
}
Toast.displayName = "Toast";
function useMounted() {
  return useSyncExternalStore(subscribe, _temp, _temp2);
}
function _temp2() {
  return !1;
}
function _temp() {
  return !0;
}
const subscribe = () => () => {
}, ToastContext = createGlobalScopedContext("@sanity/ui/context/toast", null), Root$1 = styled(Layer)`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
`, ToastContainer = styled.div`
  box-sizing: border-box;
  position: absolute;
  right: 0;
  bottom: 0;
  max-width: 420px;
  width: 100%;
`;
let toastId = 0;
function ToastProvider(props) {
  const {
    children,
    padding = 4,
    paddingX,
    paddingY,
    zOffset
  } = props, [state, _setState] = useState([]), toastsRef = useRef({}), mounted = useMounted(), prefersReducedMotion = usePrefersReducedMotion(), variants = useMemo(() => ({
    initial: {
      opacity: 0,
      [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
      y: 32,
      scale: 0.25,
      willChange: "transform"
    },
    animate: {
      opacity: [0, 1, 1],
      [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [0, 0, 1],
      y: 0,
      scale: 1
    },
    exit: {
      opacity: [1, 1, 0],
      [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [1, 0, 0],
      scale: 0.5,
      transition: prefersReducedMotion ? {
        duration: 0
      } : {
        duration: 0.2
      }
    }
  }), [prefersReducedMotion]), value = useMemo(() => ({
    version: 0,
    push: (params) => {
      const setState = (state_0) => startTransition(() => _setState(state_0)), id = params.id || String(toastId++), duration = params.duration || 5e3, dismiss = () => {
        const timeoutId = toastsRef.current[id]?.timeoutId;
        setState((prevState) => {
          const idx = prevState.findIndex((t) => t.id === id);
          if (idx > -1) {
            const toasts = prevState.slice(0);
            return toasts.splice(idx, 1), toasts;
          }
          return prevState;
        }), timeoutId !== void 0 && (clearTimeout(timeoutId), delete toastsRef.current[id]);
      };
      return setState((prevState_0) => prevState_0.filter((t_0) => t_0.id !== id).concat([{
        dismiss,
        id,
        params: {
          ...params,
          duration
        }
      }])), toastsRef.current[id] && (clearTimeout(toastsRef.current[id].timeoutId), delete toastsRef.current[id]), toastsRef.current[id] = {
        timeoutId: setTimeout(dismiss, duration)
      }, id;
    }
  }), []);
  return useEffect(() => () => {
    for (const {
      timeoutId: timeoutId_0
    } of Object.values(toastsRef.current))
      clearTimeout(timeoutId_0);
    toastsRef.current = {};
  }, []), /* @__PURE__ */ jsxs(ToastContext.Provider, { value, children: [
    children,
    mounted && /* @__PURE__ */ jsx(Root$1, { "data-ui": "ToastProvider", zOffset, children: /* @__PURE__ */ jsx(ToastContainer, { children: /* @__PURE__ */ jsx(Box, { padding, paddingX, paddingY, children: /* @__PURE__ */ jsx(AnimatePresence, { initial: !1, children: state.map(({
      dismiss: dismiss_0,
      id: id_0,
      params: params_0
    }) => /* @__PURE__ */ jsx(motion.div, { layout: "position", initial: "initial", animate: "animate", exit: "exit", variants, transition: prefersReducedMotion ? {
      duration: 0
    } : {
      type: "spring",
      damping: 30,
      stiffness: 400
    }, children: /* @__PURE__ */ jsx(Toast, { closable: params_0.closable, description: params_0.description, onClose: dismiss_0, status: params_0.status, title: params_0.title, duration: params_0.duration }) }, id_0)) }) }) }) })
  ] });
}
ToastProvider.displayName = "ToastProvider";
function useToast() {
  const value = useContext(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i])
      continue;
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
const TreeContext = createGlobalScopedContext("@sanity/ui/context/tree", null), Tree = memo(forwardRef(function(props, forwardedRef) {
  const $ = c(37);
  let t0, onFocus, children, restProps;
  $[0] !== props ? ({
    children,
    space: t0,
    onFocus,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = onFocus, $[3] = children, $[4] = restProps) : (t0 = $[1], onFocus = $[2], children = $[3], restProps = $[4]);
  const space = t0 === void 0 ? 1 : t0, ref = useRef(null), [focusedElement, setFocusedElement] = useState(null), focusedElementRef = useRef(focusedElement);
  let t1, t2;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $[5] = t2) : t2 = $[5], t1 = t2;
  const path = t1;
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = [], $[6] = t3) : t3 = $[6];
  const [itemElements, setItemElements] = useState(t3);
  let t4;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {}, $[7] = t4) : t4 = $[7];
  const [state, setState] = useState(t4), stateRef = useRef(state);
  let t5;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $[8] = t5) : t5 = $[8], useImperativeHandle(forwardedRef, t5);
  let t6, t7;
  $[9] !== focusedElement ? (t6 = () => {
    focusedElementRef.current = focusedElement;
  }, t7 = [focusedElement], $[9] = focusedElement, $[10] = t6, $[11] = t7) : (t6 = $[10], t7 = $[11]), useEffect(t6, t7);
  let t8, t9;
  $[12] !== state ? (t8 = () => {
    stateRef.current = state;
  }, t9 = [state], $[12] = state, $[13] = t8, $[14] = t9) : (t8 = $[13], t9 = $[14]), useEffect(t8, t9);
  let t10;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (element, path_0, expanded, selected) => (setState((s) => ({
    ...s,
    [path_0]: {
      element,
      expanded
    }
  })), selected && setFocusedElement(element), () => {
    setState((s_0) => {
      const newState = {
        ...s_0
      };
      return delete newState[path_0], newState;
    });
  }), $[15] = t10) : t10 = $[15];
  const registerItem = t10;
  let t11;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (path_1, expanded_0) => {
    setState((s_1) => {
      const itemState = s_1[path_1];
      return itemState ? {
        ...s_1,
        [path_1]: {
          ...itemState,
          expanded: expanded_0
        }
      } : s_1;
    });
  }, $[16] = t11) : t11 = $[16];
  const setExpanded = t11;
  let t12;
  const t13 = focusedElement || itemElements[0] || null;
  let t14;
  $[17] !== t13 || $[18] !== space || $[19] !== state ? (t14 = {
    version: 0,
    focusedElement: t13,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }, $[17] = t13, $[18] = space, $[19] = state, $[20] = t14) : t14 = $[20], t12 = t14;
  const contextValue = t12;
  let t15;
  $[21] !== itemElements ? (t15 = (event) => {
    if (focusedElementRef.current) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
        nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
        prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
        return;
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!itemKey)
          return;
        const itemState_0 = stateRef.current[itemKey];
        if (!itemState_0)
          return;
        if (itemState_0.expanded)
          setState((s_2) => {
            const itemState_1 = s_2[itemKey];
            return itemState_1 ? {
              ...s_2,
              [itemKey]: {
                ...itemState_1,
                expanded: !1
              }
            } : s_2;
          });
        else {
          const itemPath = itemKey.split("/");
          itemPath.pop();
          const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
          parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
        }
        return;
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!focusedKey)
          return;
        stateRef.current[focusedKey]?.expanded || setState((s_3) => {
          const itemState_2 = s_3[focusedKey];
          return itemState_2 ? {
            ...s_3,
            [focusedKey]: {
              ...itemState_2,
              expanded: !0
            }
          } : s_3;
        });
        return;
      }
    }
  }, $[21] = itemElements, $[22] = t15) : t15 = $[22];
  const handleKeyDown = t15;
  let t16;
  $[23] !== onFocus ? (t16 = (event_0) => {
    setFocusedElement(event_0.target), onFocus?.(event_0);
  }, $[23] = onFocus, $[24] = t16) : t16 = $[24];
  const handleFocus = t16;
  let t17;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t17 = () => {
    if (!ref.current)
      return;
    const _itemElements = Array.from(ref.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, $[25] = t17) : t17 = $[25];
  let t18;
  $[26] !== children ? (t18 = [children], $[26] = children, $[27] = t18) : t18 = $[27], useEffect(t17, t18);
  let t19;
  $[28] !== restProps || $[29] !== handleFocus || $[30] !== handleKeyDown || $[31] !== space || $[32] !== children ? (t19 = /* @__PURE__ */ jsx(Stack, { as: "ul", "data-ui": "Tree", ...restProps, onFocus: handleFocus, onKeyDown: handleKeyDown, ref, role: "tree", space, children }), $[28] = restProps, $[29] = handleFocus, $[30] = handleKeyDown, $[31] = space, $[32] = children, $[33] = t19) : t19 = $[33];
  let t20;
  return $[34] !== contextValue || $[35] !== t19 ? (t20 = /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: t19 }), $[34] = contextValue, $[35] = t19, $[36] = t20) : t20 = $[36], t20;
}));
Tree.displayName = "Memo(ForwardRef(Tree))";
function treeItemRootStyle() {
  return css`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", {
    color
  } = getTheme_v2(props.theme), tone = color.selectable[$tone];
  return css`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return css`
    padding-left: ${rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = useContext(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
const TreeGroup = memo(function(props) {
  const $ = c(9);
  let t0, restProps, children;
  $[0] !== props ? ({
    children,
    expanded: t0,
    ...restProps
  } = props, $[0] = props, $[1] = t0, $[2] = restProps, $[3] = children) : (t0 = $[1], restProps = $[2], children = $[3]);
  const expanded = t0 === void 0 ? !1 : t0, tree = useTree(), t1 = !expanded;
  let t2;
  return $[4] !== restProps || $[5] !== t1 || $[6] !== tree.space || $[7] !== children ? (t2 = /* @__PURE__ */ jsx(Stack, { as: "ul", "data-ui": "TreeGroup", ...restProps, hidden: t1, marginTop: tree.space, role: "group", space: tree.space, children }), $[4] = restProps, $[5] = t1, $[6] = tree.space, $[7] = children, $[8] = t2) : t2 = $[8], t2;
}), Root = memo(styled.li(treeItemRootStyle, treeItemRootColorStyle)), TreeItemBox = styled(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle), ToggleArrowText = styled(Text)`
  & > svg {
    transition: transform 100ms;
  }
`, TreeItem = memo(function(props) {
  const {
    children,
    expanded: expandedProp = !1,
    fontSize: fontSize2 = 1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = !1,
    space = 2,
    text,
    weight,
    ...restProps
  } = props, rootRef = useRef(null), treeitemRef = useRef(null), tree = useTree(), {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree, _id = useId(), id = idProp || _id, itemPath = useMemo(() => path.concat([id || ""]), [id, path]), itemKey = itemPath.join("/"), itemState = tree.state[itemKey], focused = tree.focusedElement === rootRef.current, expanded = itemState?.expanded === void 0 ? expandedProp : itemState?.expanded || !1, tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1, contextValue = useMemo(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]), handleClick = useCallback((event) => {
    onClick && onClick(event);
    const target = event.target;
    target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootRef.current));
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]), handleKeyDown = useCallback((event_0) => {
    focused && event_0.key === "Enter" && (treeitemRef.current || rootRef.current)?.click();
  }, [focused]);
  useEffect(() => {
    if (rootRef.current)
      return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */ jsxs(Flex, { padding, children: [
    /* @__PURE__ */ jsxs(Box, { marginRight: space, style: {
      visibility: IconComponent || children ? "visible" : "hidden",
      pointerEvents: "none"
    }, children: [
      IconComponent && /* @__PURE__ */ jsx(Text, { muted, size: fontSize2, weight, children: /* @__PURE__ */ jsx(IconComponent, {}) }),
      !IconComponent && /* @__PURE__ */ jsx(ToggleArrowText, { muted, size: fontSize2, weight, children: /* @__PURE__ */ jsx(ToggleArrowRightIcon, { style: {
        transform: expanded ? "rotate(90deg)" : void 0
      } }) })
    ] }),
    /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { muted, size: fontSize2, textOverflow: "ellipsis", weight, children: text }) })
  ] });
  return href ? /* @__PURE__ */ jsxs(Root, { "data-selected": selected ? "" : void 0, "data-tree-id": id, "data-tree-key": itemKey, "data-ui": "TreeItem", ...restProps, onClick: handleClick, ref: rootRef, role: "none", children: [
    /* @__PURE__ */ jsx(TreeItemBox, { $level: tree.level, "aria-expanded": expanded, as: linkAs, "data-ui": "TreeItem__box", href, ref: treeitemRef, role: "treeitem", tabIndex, children: content }),
    /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsx(TreeGroup, { hidden: !expanded, children }) })
  ] }) : /* @__PURE__ */ jsxs(Root, { "data-selected": selected ? "" : void 0, "data-ui": "TreeItem", "data-tree-id": id, "data-tree-key": itemKey, ...restProps, "aria-expanded": expanded, onClick: handleClick, onKeyDown: handleKeyDown, ref: rootRef, role: "treeitem", tabIndex, children: [
    /* @__PURE__ */ jsx(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content }),
    /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsx(TreeGroup, { expanded, children }) })
  ] });
});
TreeItem.displayName = "Memo(TreeItem)";
export {
  Arrow,
  Autocomplete,
  Avatar,
  AvatarCounter,
  AvatarStack,
  Badge,
  BoundaryElementProvider,
  Box,
  Breadcrumbs,
  Button,
  Card,
  Checkbox,
  Code,
  CodeSkeleton,
  ConditionalWrapper,
  Container,
  Dialog,
  DialogContext,
  DialogProvider,
  ElementQuery,
  ErrorBoundary,
  Flex,
  Grid,
  Heading,
  HeadingSkeleton,
  Hotkeys,
  Inline,
  KBD,
  Label,
  LabelSkeleton,
  Layer,
  LayerProvider,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  Popover,
  Portal,
  PortalProvider,
  Radio,
  Select,
  Skeleton,
  Spinner,
  SrOnly,
  Stack,
  Switch,
  Tab,
  TabList,
  TabPanel,
  Text,
  TextArea,
  TextInput,
  TextSkeleton,
  ThemeColorProvider,
  ThemeProvider,
  Toast,
  ToastProvider,
  Tooltip,
  TooltipDelayGroupContext,
  TooltipDelayGroupProvider,
  Tree,
  TreeItem,
  VirtualList,
  _ResizeObserver,
  _elementSizeObserver,
  _fillCSSObject,
  _getArrayProp,
  _getResponsiveSpace,
  _hasFocus,
  _isEnterToClickElement,
  _isScrollable,
  _raf,
  _raf2,
  _responsive,
  attemptFocus,
  containsOrEqualsElement,
  createColorTheme,
  focusFirstDescendant,
  focusLastDescendant,
  hexToRgb,
  hslToRgb,
  isFocusable,
  isHTMLAnchorElement,
  isHTMLButtonElement,
  isHTMLElement,
  isHTMLInputElement,
  isHTMLSelectElement,
  isHTMLTextAreaElement,
  multiply,
  parseColor,
  rem,
  responsiveCodeFontStyle,
  responsiveHeadingFont,
  responsiveLabelFont,
  responsiveTextAlignStyle,
  responsiveTextFont,
  rgbToHex,
  rgbToHsl,
  rgba,
  screen,
  studioTheme,
  useArrayProp,
  useBoundaryElement,
  useClickOutside,
  useClickOutsideEvent,
  useCustomValidity,
  useDialog,
  useElementRect,
  useElementSize,
  useForwardedRef,
  useGlobalKeyDown,
  useLayer,
  useMatchMedia,
  useMediaIndex,
  usePortal,
  usePrefersDark,
  usePrefersReducedMotion,
  useRootTheme,
  useTheme,
  useTheme_v2,
  useToast,
  useTooltipDelayGroup,
  useTree
};
//# sourceMappingURL=index.mjs.map

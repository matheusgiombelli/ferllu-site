{"version":3,"file":"index.cjs","sources":["../src/useObservable.ts","../src/useObservableEvent.ts"],"sourcesContent":["import {useCallback, useMemo, useSyncExternalStore} from 'react'\nimport {\n  asapScheduler,\n  catchError,\n  finalize,\n  type Observable,\n  type ObservedValueOf,\n  of,\n  share,\n  timer,\n} from 'rxjs'\nimport {map, tap} from 'rxjs/operators'\n\nfunction getValue<T>(value: T): T extends () => infer U ? U : T {\n  return typeof value === 'function' ? value() : value\n}\n\ninterface ObservableState<T> {\n  didEmit: boolean\n  snapshot?: T\n  error?: unknown\n}\n\ninterface CacheRecord<T> {\n  observable: Observable<void>\n  state: {\n    didEmit: boolean\n    snapshot?: T\n    error?: unknown\n  }\n  getSnapshot: (initialValue: unknown) => T\n}\n\nconst cache = new WeakMap<Observable<any>, CacheRecord<any>>()\n\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>>(\n  observable: ObservableType,\n  initialValue: ObservedValueOf<ObservableType> | (() => ObservedValueOf<ObservableType>),\n): ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>>(\n  observable: ObservableType,\n): undefined | ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>, InitialValue>(\n  observable: ObservableType,\n  initialValue: InitialValue | (() => InitialValue),\n): InitialValue | ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>, InitialValue>(\n  observable: ObservableType,\n  initialValue?: InitialValue | (() => InitialValue),\n): InitialValue | ObservedValueOf<ObservableType> {\n  const instance = useMemo(() => {\n    if (!cache.has(observable)) {\n      // This separate object is used as a stable reference to the cache entry's snapshot and error.\n      // It's used by the `getSnapshot` closure.\n      const state: ObservableState<ObservedValueOf<ObservableType>> = {\n        didEmit: false,\n      }\n      const entry: CacheRecord<ObservedValueOf<ObservableType>> = {\n        state,\n        observable: observable.pipe(\n          map((value) => ({snapshot: value, error: undefined})),\n          catchError((error) => of({snapshot: undefined, error})),\n          tap(({snapshot, error}) => {\n            state.didEmit = true\n            state.snapshot = snapshot\n            state.error = error\n          }),\n          // Note: any value or error emitted by the provided observable will be mapped to the cache entry's mutable state\n          // and the observable is thereafter only used as a notifier to call `onStoreChange`, hence the `void` return type.\n          map((value) => void value),\n          // Ensure that the cache entry is deleted when the observable completes or errors.\n          finalize(() => cache.delete(observable)),\n          share({resetOnRefCountZero: () => timer(0, asapScheduler)}),\n        ),\n        getSnapshot: (initialValue) => {\n          if (state.error) {\n            throw state.error\n          }\n          return (\n            state.didEmit ? state.snapshot : getValue(initialValue)\n          ) as ObservedValueOf<ObservableType>\n        },\n      }\n\n      // Eagerly subscribe to sync set `state.snapshot` to what the observable returns, and keep the observable alive until the component unmounts.\n      const subscription = entry.observable.subscribe()\n      subscription.unsubscribe()\n\n      cache.set(observable, entry)\n    }\n    return cache.get(observable)!\n  }, [observable])\n\n  const subscribe = useCallback(\n    (onStoreChange: () => void) => {\n      const subscription = instance.observable.subscribe(onStoreChange)\n      return () => {\n        subscription.unsubscribe()\n      }\n    },\n    [instance.observable],\n  )\n\n  return useSyncExternalStore<ObservedValueOf<ObservableType>>(\n    subscribe,\n    () => {\n      return instance.getSnapshot(initialValue)\n    },\n    typeof initialValue === 'undefined'\n      ? undefined\n      : () => getValue(initialValue) as ObservedValueOf<ObservableType>,\n  )\n}\n","import {observableCallback} from 'observable-callback'\nimport {useEffect, useState} from 'react'\nimport {type Observable} from 'rxjs'\nimport {useEffectEvent} from 'use-effect-event'\n\n/** @public */\nexport function useObservableEvent<T, U>(\n  handleEvent: (arg: Observable<T>) => Observable<U>,\n): (arg: T) => void {\n  const [[calls$, call]] = useState(() => observableCallback<T>())\n\n  const onEvent = useEffectEvent((observable: Observable<T>) => handleEvent(observable))\n\n  useEffect(() => {\n    const subscription = calls$.pipe((observable) => onEvent(observable)).subscribe()\n    return () => subscription.unsubscribe()\n  }, [calls$, onEvent])\n\n  return call\n}\n"],"names":["getValue","value","cache","WeakMap","useObservable","observable","initialValue","$","_c","t0","has","state","didEmit","entry","pipe","map","snapshot","error","undefined","catchError","of","tap","t1","error_0","value_0","finalize","delete","share","resetOnRefCountZero","timer","asapScheduler","getSnapshot","initialValue_0","subscribe","unsubscribe","set","get","instance","t2","onStoreChange","subscription_0","subscription","t3","t4","useSyncExternalStore","useObservableEvent","handleEvent","useState","_temp","calls$","call","onEvent","useEffectEvent","observable_0","useEffect","observableCallback"],"mappings":"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"}